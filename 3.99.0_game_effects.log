[22:34:30][game_application.cpp:2194]: 
== EFFECT DOCUMENTATION ==
tooltip - Just a tooltip
Supported Scopes: all

win - The scoped country wins the game
win = yes
Supported Scopes: country

hidden_effect - Prevents enclosed effects from being displayed in tooltip
hidden_effect = { <effects> }
Supported Scopes: all

custom_tooltip - Displays a specific localization string in tooltip
custom_tooltip = <string>
Supported Scopes: all

if - Executes enclosed effects if limit criteria are met
if = { limit = { <triggers> } <effects> }
Supported Scopes: all

end_all_treaties_with - Ends all treaties with the target
end_all_treaties_with = <target>
Supported Scopes: country

random_list - Picks one random set of effects from a list, influenced by relative weight
random_list = { 50 = { <effects> } 20 = { <effects> } 30 = { <effects> } 999 = { <effects> } }
Supported Scopes: all

locked_random_list - Picks one random set of effects from a list, influenced by relative weight once per event scope
locked_random_list = { 50 = { <effects> } 20 = { <effects> } 30 = { <effects> } 999 = { <effects> } }
Supported Scopes: all

remove_deposit - Remove resource deposit on the scoped planet or deposit, does not fire on_cleared if used on a blocker
remove_deposit = <key/yes>
Supported Scopes: planet deposit astral_rift

add_blocker - Adds a blocker to a planet, with some control over what it is set to block (add_deposit will add a random planetary deposit to block)
add_blocker = {
	type = <key>
	blocked_deposit = none (default)/<deposit scope - copies the type to the blocked deposit but any flags or variables are lost>/random
}
Supported Scopes: planet

set_owner - Instantly sets the owner of the scoped planet/fleet/army/starbase to target country
set_owner = <target>
Supported Scopes: megastructure planet fleet leader army starbase

unemploy_pop - Fires scoped pop from its job
unemploy_pop = yes
Supported Scopes: pop

check_planet_employment - Immediately runs a job evaluation on the planet, firing and employing pops as needed
check_planet_employment = yes
Supported Scopes: planet

change_species_portrait - Changes the portrait of the species in scope.
change_species_portrait = <key or species event target>
Supported Scopes: species

add_random_non_blocker_deposit - Adds random non-blocker resource deposit to the scoped planet
add_random_non_blocker_deposit = yes
Supported Scopes: planet

remove_random_building - Removes last built building from the scoped planet
remove_random_building = yes
Supported Scopes: planet

remove_all_buildings - Removes all buildings from the scoped planet
remove_all_buildings = yes
Supported Scopes: planet

repair_all_buildings - Repairs all ruined buildings on the scoped planet
repair_all_buildings = yes
Supported Scopes: planet

downgrade_all_buildings - Downgrades all non-capital buildings on the scoped planet/country. Leaves tier 1 buildings untouched.
downgrade_all_buildings = yes
Supported Scopes: planet country

downgrade_buildings_of_type - Downgrades all buildings of a specified type on the planet/country.
downgrade_buildings_of_type = yes
Supported Scopes: planet country

validate_and_repair_planet_buildings_and_districts - Replace/removes all invalid (potential trigger not fulfilled) buildings and districts, then repairs all ruined buildings on the scoped planet
validate_and_repair_planet_buildings_and_districts = yes
Supported Scopes: planet

remove_holding - Removes a specific holding from the scoped planet
remove_holding = { holding = <key> owner = <owner> }
Supported Scopes: planet

add_holding - Begins construction of a specific holding on the scoped planet
add_holding = { holding = <key> owner = <owner> }
Supported Scopes: planet

give_technology - Instantly gives a specific tech to the scoped country
give_technology = { tech = tech_desert_colonization message = yes }
Supported Scopes: country

add_building - Begins construction of a specific building on the scoped planet
add_building = <key>
Supported Scopes: planet

ruin_building - Ruins a single instance of a specific building on the scoped planet
ruin_building = <key>/random_no_capital
Supported Scopes: planet

disable_building - Disables a single instance of a specific building on the scoped planet
disable_building = <key>
Supported Scopes: planet

change_background_ethic - Changes the background ethic of a leader
change_background_ethic = <key>
Supported Scopes: leader

change_background_job - Changes the background job of a leader
change_background_job = <key>
Supported Scopes: all

add_planet_devastation - Instantly adds devastation to scoped planet
add_planet_devastation = 5
Supported Scopes: planet

set_immortal - Sets the scoped leader immortal. The 'no' case will not override immortality granted by species characteristics (but will disable immortality granted by this effect).
set_immortal = yes
Supported Scopes: leader

freeze_leader_age - Freezes the scoped leader's age. The 'no' case will disable the freeze granted by this effect.
freeze_leader_age = yes
Supported Scopes: leader

calculate_modifier - Forces target planet or country to calculate its internal modifier
calculate_modifier = yes
Supported Scopes: planet country

establish_branch_office - Establish branch office on scoped planet for target country
establish_branch_office = <target>
Supported Scopes: planet

close_branch_office - Close branch office on scoped planet
close_branch_office = yes
Supported Scopes: planet

clear_blockers - Removes all blockers from the scoped planet
clear_blockers = yes
Supported Scopes: planet

set_built_species - Changes the built species of the scoped object
set_built_species = <target>
Supported Scopes: country

set_first_contact_flag - Sets an arbitrarily-named flag on the scoped first contact site
set_first_contact_flag = <key> (note: one can use e.g. my_flag@from to track relationships between objects)
Supported Scopes: first_contact

set_situation_flag - Sets an arbitrarily-named flag on the scoped situation
set_situation_flag = <key> (note: one can use e.g. my_flag@from to track relationships between objects)
Supported Scopes: situation

set_agreement_flag - Sets an arbitrarily-named flag on the scoped agreement
set_agreement_flag = <key> (note: one can use e.g. my_flag@from to track relationships between objects)
Supported Scopes: agreement

set_federation_flag - Sets an arbitrarily-named flag on the scoped federation
set_federation_flag = <key> (note: one can use e.g. my_flag@from to track relationships between objects)
Supported Scopes: federation

set_country_flag - Sets an arbitrarily-named flag on the scoped country
set_country_flag = <key> (note: one can use e.g. my_flag@from to track relationships between objects)
Supported Scopes: country

set_planet_flag - Sets an arbitrarily-named flag on the scoped planet
set_planet_flag = <key> (note: one can use e.g. my_flag@from to track relationships between objects)
Supported Scopes: planet

set_fleet_flag - Sets an arbitrarily-named flag on the scoped fleet
set_fleet_flag = <key> (note: one can use e.g. my_flag@from to track relationships between objects)
Supported Scopes: fleet

set_ship_flag - Sets an arbitrarily-named flag on the scoped ship
set_ship_flag = <key> (note: one can use e.g. my_flag@from to track relationships between objects)
Supported Scopes: ship

set_astral_rift_flag - Sets an arbitrarily-named flag on the scoped astral rift
set_astral_rift_flag = <key> (note: one can use e.g. my_flag@from to track relationships between objects)
Supported Scopes: astral_rift

remove_first_contact_flag - Removes a flag from the scoped first contact site
remove_first_contact_flag = <key> (note: one can use e.g. my_flag@from to track relationships between objects)
Supported Scopes: first_contact

remove_situation_flag - Removes a flag from the scoped situation
remove_situation_flag = <key> (note: one can use e.g. my_flag@from to track relationships between objects)
Supported Scopes: situation

remove_agreement_flag - Removes a flag from the scoped agreement
remove_agreement_flag = <key> (note: one can use e.g. my_flag@from to track relationships between objects)
Supported Scopes: agreement

remove_federation_flag - Removes a flag from the scoped federation
remove_federation_flag = <key> (note: one can use e.g. my_flag@from to track relationships between objects)
Supported Scopes: federation

remove_country_flag - Removes a flag from the scoped country
remove_country_flag = <key> (note: one can use e.g. my_flag@from to track relationships between objects)
Supported Scopes: country

remove_planet_flag - Removes a flag from the scoped planet
remove_planet_flag = <key> (note: one can use e.g. my_flag@from to track relationships between objects)
Supported Scopes: planet

remove_fleet_flag - Removes a flag from the scoped fleet
remove_fleet_flag = <key> (note: one can use e.g. my_flag@from to track relationships between objects)
Supported Scopes: fleet

remove_ship_flag - Removes a flag from the scoped ship
remove_ship_flag = <key> (note: one can use e.g. my_flag@from to track relationships between objects)
Supported Scopes: ship

remove_astral_rift_flag - Removes a flag from the scoped astral rift
remove_astral_rift_flag = <key> (note: one can use e.g. my_flag@from to track relationships between objects)
Supported Scopes: astral_rift

create_species - Creates a new species. The habitability trait is determined by homeworld, traits = random, traits = { ideal_planet_class = <pc_XYZ> }, traits = <trait_pc_XYZ_preference>, or else is assigned randomly.
create_species = {
	name = <string>/random/scope
	plural = <string>/this
	class = <species class key>/random/random_non_machine/random_pre_ftl/scope
	portrait = <random/portrait id>/this
	homeworld = <target>
	traits = { <traits> }/random/this
	sapient = yes/no, determines if species is sapient (default: yes)
	is_mod = yes/no, determines if species is a modification of another (default: no)
	immortal = yes/no, determines if species leaders are immortal (default: no)
	can_be_modified = yes/no/this (default: yes)
	gender = <species/leader>/male/female/indeterminate/not_set
	clear_parent_species_link = yes/no (default: no)
	extra_trait_points = <int>
	allow_negative_traits = yes/no (default: yes)
	namelist = random/random_class/scope
	effect = {}
}
Supported Scopes: all

create_country - Creates a new country
create_country = {
	name = <string/random>
	adjective = <string>
	contact_rule = <string>
 type = <key>
	auto_delete = <bool>
	name_list = <key>
	ship_prefix = <string>
	authority = <key>
	civics = random / { civic = <key> civic = random }
	species = <target>
	flag = <random / { icon = { category = <key> file = <filename.dds> } background = { category = <key> file = <filename.dds> } colors = { <key> <key> } }
	ethos = <random / { ethic = <key> ethic = <key> }>
	restrictions = { <restrictions, see "common\governments\readme_requirements.txt"> }
	set_capital_from_species = yes/no
	effect = { <effects executed on country> }
}
Supported Scopes: all

create_fleet - Creates a new fleet
create_fleet = { name = <string> effect = { <create_ship, set_owner, set_location etc effects go here> } } 
Supported Scopes: all

create_army - Creates a new army
create_army = {
	name = <string>
	owner = <target>
	species = <target>/random
	type = <key>
}
Supported Scopes: planet

modify_army - Modifies army with parameters:
modify_army = {
	name = <string>
	owner = <target>
	species = <target>/random
	type = <key>
}
Supported Scopes: army

set_location - Sets the fleet/ambient object's location, can be fine-tuned
set_location = <target>
set_location = {
	target = <target>
	distance = <int/random>
	angle = <int/random>
	direction = <in_system/out_system>
}
Supported Scopes: fleet ambient_object

create_ship - Creates a new ship
create_ship = {
	name = <string/random>
	design = <ship design key/target/last_created_design, or use random_existing_design>
	random_existing_design = <ship size key>
	graphical_culture = <graphical culture key> graphical_culture_fallback = <graphical culture key>
prefix = <Y/N, determines if ship name should use owner country prefix>
	colonizer_species = <species, default: fleet owner founder species> age = <int> (optional)
	rarity = <common/rare/epic/exceptional, used only if ship is space fauna> (optional, fallbacks to highest owned genetic material if applicable but not set)
}
Supported Scopes: fleet starbase

set_awareness - Sets awareness for the scoped (pre-FTL) country
set_awareness = 52.3
Supported Scopes: country

add_awareness - Adds awareness to the scoped (pre-FTL) country
add_awareness = 12.3
Supported Scopes: country

create_pop - Adds pop size on the scoped planet
create_pop = {
	species = <target / key>
ethos = <random / <target country> / { ethic = <key> ethic = <key> size = <number> (optional, default: POP_BULK_UNIT_SIZE) }>
}
Supported Scopes: planet

create_pop_group - Creates a new pop group based on an existing one with overrides. If no existing pop group is passed, species is mandatory.
create_pop_group = {
	pop_group = <base pop group> (optional; if omitted, species is required)
	species = last_created / <key> / <target> / random (optional; if omitted, base pop group is required)
	ethos = <target country> / { ethic = <key> ethic = <key> } / random (optional; if no base group and no ethic is provided, ethos will be randomized)
	pop_category = <pop category> (optional; if omitted and no base group is defined, use lowest rank pop category)
	size = <number> (optional, default: POP_BULK_UNIT_SIZE)
	effect = <init effect> (optional)
}
Supported Scopes: planet

create_colony - Creates a colony on the scoped planet
create_colony = {
	owner = <target>
	species = <target / key>
	ethos = <random / target / { ethic = <key> ethic = <key> }>
}
Supported Scopes: planet

set_capital - Sets the scoped planet to be the capital of its owner country
set_capital = yes
Supported Scopes: planet

change_pc - Changes the class of the scoped planet
change_pc = <class/random list>
change_pc = { class = <class/random list> inherit_entity = yes }
Supported Scopes: planet

start_terraform_process - Starts terraforming process of scoped planet
start_terraform_process = <class/random list>
start_terraform_process = { class = <class/random list> inherit_entity = yes }
Supported Scopes: planet

set_star_class - Sets the star's star class, affecting system and galactic map graphics and potentially modifiers. Also changes the planet class of the system's primary star.
set_star_class = <star class>
Supported Scopes: galactic_object

kill_pop - Instantly destroys the scoped pop
kill_pop = yes
Supported Scopes: pop pop group

kill_pop_group - Instantly destroys part of a pop group
kill_pop_group = { pop_group = <target pop group> amount = <amount (or percentage%) killed> }
Supported Scopes: all

destroy_colony - Destroys the colony on the scoped planet
destroy_colony = yes
Supported Scopes: planet

add_experience - Adds a sum of experience points to the scoped leader
add_experience = 200
Supported Scopes: leader

set_ring - Adds or removes a planetary ring around the scoped planet
set_ring = no
Supported Scopes: planet

create_mining_station - Creates a mining station in orbit of the scoped planet
create_mining_station = { owner = <target> }
Supported Scopes: planet astral_rift

create_research_station - Creates a research station in orbit of the scoped planet
create_research_station = { owner = <target> }
Supported Scopes: planet astral_rift

set_pop_flag - Sets an arbitrarily-named flag on the scoped pop
set_pop_flag = <key> (note: one can use e.g. my_flag@from to track relationships between objects)
Supported Scopes: pop

remove_pop_flag - Removes a flag from the scoped pop
remove_pop_flag = <key> (note: one can use e.g. my_flag@from to track relationships between objects)
Supported Scopes: pop

set_pop_group_flag - Sets an arbitrarily-named flag on the scoped pop group
set_pop_group_flag = <key> (note: one can use e.g. my_flag@from to track relationships between objects)
Supported Scopes: pop group

remove_pop_group_flag - Removes a flag from the scoped pop group
remove_pop_group_flag = <key> (note: one can use e.g. my_flag@from to track relationships between objects)
Supported Scopes: pop group

set_name - Sets the name of the scoped country/planet/ship/fleet/leader/army/system/pop faction
set_name = <string>/<target>
Supported Scopes: megastructure planet country ship fleet galactic_object leader army pop_faction war federation sector first_contact

set_adjective - Sets the adjective of the scoped country
set_adjective = <string>
Supported Scopes: country

set_ship_prefix - Sets the ship prefix of the scoped country
set_ship_prefix = <string>
Supported Scopes: country

add_modifier - Adds a specific modifier to the scoped object for a set duration
add_modifier = {
	modifier = <key>
	days/months/years = <int, -1 (default) means it never expires>
	multiplier = <float>/<variable> (optional)
	time_multiplier = <variable> (optional: days/months/years value is multiplied by the value of this variable)
	clear_on_owner_change = yes (optional: default no; clears modifier if planet/system/megastructure's owner changes)
}
Supported Scopes: megastructure planet country ship pop pop group fleet galactic_object pop_faction federation starbase spy_network espionage_operation astral_rift cosmic_storm_influence_field

reduce_hp - Reduces the hull points of the scoped ship by a specific amount
reduce_hp = 120
Supported Scopes: ship

reduce_hp_percent - Reduces the hull points of the scoped ship by a relative amount
reduce_hp_percent = 0.25
Supported Scopes: ship

reduce_shield - Reduces the shield points of the scoped ship by a specific amount
reduce_shield = 120
Supported Scopes: ship

damage_ship - Damages ship by a specific amount
damage_ship = 120
Supported Scopes: ship

repair_ship - Restores all hull points to the scoped ship
repair_ship = yes
Supported Scopes: ship

set_surveyed - Sets the planet/astral rift or system as un/surveyed by target country
set_surveyed = { surveyed = yes surveyor = <target> }
Supported Scopes: planet galactic_object astral_rift

set_visited - Sets the target system as 'visited' (i.e. low system intel on the map)
set_visited = <target>
Supported Scopes: country

destroy_country - Destroys the scoped country
destroy_country = yes
Supported Scopes: country

set_variable - Sets or creates an arbitrarily-named variable with a specific value in the current scope
set_variable = { which = <string> value = <float>/<variable>/<scope.variable>/trigger:<trigger> }
Supported Scopes: megastructure planet country ship pop pop group fleet galactic_object leader army ambient_object species bypass pop_faction war federation starbase deposit sector archaeological_site first_contact spy_network espionage_operation espionage_asset agreement situation astral_rift

clear_variable - Clears a previously-set variable from the game.
clear_variable = <string>
Supported Scopes: megastructure planet country ship pop pop group fleet galactic_object leader army ambient_object species bypass pop_faction war federation starbase deposit sector archaeological_site first_contact spy_network espionage_operation espionage_asset agreement situation astral_rift

round_variable - Rounds a previously-set variable to the closest integer.
round_variable = <string>
Supported Scopes: megastructure planet country ship pop pop group fleet galactic_object leader army ambient_object species bypass pop_faction war federation starbase deposit sector archaeological_site first_contact spy_network espionage_operation espionage_asset agreement situation astral_rift

floor_variable - Rounds a previously-set variable down to the previous integer.
floor_variable = <string>
Supported Scopes: megastructure planet country ship pop pop group fleet galactic_object leader army ambient_object species bypass pop_faction war federation starbase deposit sector archaeological_site first_contact spy_network espionage_operation espionage_asset agreement situation astral_rift

ceiling_variable - Rounds a previously-set variable up to the next integer.
ceiling_variable = <string>
Supported Scopes: megastructure planet country ship pop pop group fleet galactic_object leader army ambient_object species bypass pop_faction war federation starbase deposit sector archaeological_site first_contact spy_network espionage_operation espionage_asset agreement situation astral_rift

export_modifier_to_variable - Exports the value of a specified modifier in the current scope to a specified variable.
export_modifier_to_variable = { modifier = pop_growth_speed_reduction variable = <string> }
Supported Scopes: megastructure planet country ship pop pop group fleet galactic_object leader army species pop_faction

export_modifier_duration_to_variable - Exports the remaining duration of a specified modifier in the current scope to a specified variable.
export_modifier_duration_to_variable = { modifier = modifier_name variable = <string> }
Supported Scopes: planet country pop pop group fleet

export_trigger_value_to_variable - Exports the value of a trigger to a specified variable (so for num_pops, it'll export the number of pops).
export_trigger_value_to_variable = {
	trigger = pop_produces_resource
	parameters = { resource = energy } (optional: specify extra parameters for triggers with { }
	variable = <string> (this example will print the amount of energy the pop produces to a variable)
	rounded = yes (default: no)
}
Supported Scopes: megastructure planet country ship pop pop group fleet galactic_object leader army ambient_object species bypass pop_faction war federation starbase deposit sector archaeological_site first_contact spy_network espionage_operation espionage_asset agreement situation astral_rift

export_resource_stockpile_to_variable - Exports the value of the current country's stockpile of the specified resource to a variable.
export_resource_stockpile_to_variable = { resource = energy variable = <string> }
Supported Scopes: country

export_resource_income_to_variable - Exports the value of the current country's monthly income of the specified resource to a variable.
export_resource_income_to_variable = { resource = energy variable = <string> }
Supported Scopes: country

export_resource_maximum_to_variable - Exports the value of the current country's maximum of the specified resource to a variable.
export_resource_maximum_to_variable = { resource = energy variable = <string> }
Supported Scopes: country

set_variable_to_random_value - Sets a variable to a random value within the specified bounds.
set_variable_to_random_value = { which = <some_variable> min = -100 max = 100 rounded = yes/no }
Supported Scopes: megastructure planet country ship pop pop group fleet galactic_object leader army ambient_object species bypass pop_faction war federation starbase deposit sector archaeological_site first_contact spy_network espionage_operation espionage_asset agreement situation astral_rift

remove_global_flag - Removes a global flag
remove_global_flag = <key> (note: one can use e.g. my_flag@from to track relationships between objects)
Supported Scopes: all

set_global_flag - Sets an arbitrarily-named global flag
set_global_flag = <key> (note: one can use e.g. my_flag@from to track relationships between objects)
Supported Scopes: all

change_variable - Increments a previously-set variable by a specific amount
change_variable = { which = <string> value = <float>/<variable>/<scope.variable>/trigger:<trigger> }
Supported Scopes: megastructure planet country ship pop pop group fleet galactic_object leader army ambient_object species bypass pop_faction war federation starbase deposit sector archaeological_site first_contact spy_network espionage_operation espionage_asset agreement situation astral_rift

set_event_locked - Silently disables the scoped fleet to prevent player action, remember to unlock at the end of the event
set_event_locked = no
Supported Scopes: fleet

clear_orders - Clears all fleet orders from the scoped fleet
clear_orders = yes
Supported Scopes: fleet

order_forced_return - Forces scoped fleet to retreat to friendly territory
order_forced_return = yes
Supported Scopes: fleet

declare_war - Declares war between the scoped country and target country
declare_war = {
	target = <target country>
	name = <optional war name>
	attacker_war_goal = <war goal>
}
Supported Scopes: country

set_star_flag - Sets an arbitrarily-named flag on the scoped system
set_star_flag = <key> (note: one can use e.g. my_flag@from to track relationships between objects)
Supported Scopes: galactic_object

remove_star_flag - Removes a flag from the scoped system
remove_star_flag = <key> (note: one can use e.g. my_flag@from to track relationships between objects)
Supported Scopes: galactic_object

set_army_flag - Sets an arbitrarily-named flag on the scoped army
set_army_flag = <key> (note: one can use e.g. my_flag@from to track relationships between objects)
Supported Scopes: army

set_deposit_flag - Sets an arbitrarily-named flag on the scoped deposit
set_deposit_flag = <key> (note: one can use e.g. my_flag@from to track relationships between objects)
Supported Scopes: deposit

set_war_flag - Sets an arbitrarily-named flag on the scoped war
set_war_flag = <key> (note: one can use e.g. my_flag@from to track relationships between objects)
Supported Scopes: war

set_starbase_flag - Sets an arbitrarily-named flag on the scoped starbase
set_starbase_flag = <key> (note: one can use e.g. my_flag@from to track relationships between objects)
Supported Scopes: starbase

set_sector_flag - Sets an arbitrarily-named flag on the scoped sector
set_sector_flag = <key> (note: one can use e.g. my_flag@from to track relationships between objects)
Supported Scopes: sector

set_archaeology_flag - Sets an arbitrarily-named flag on the scoped arc site
set_archaeology_flag = <key> (note: one can use e.g. my_flag@from to track relationships between objects)
Supported Scopes: archaeological_site

set_spynetwork_flag - Sets an arbitrarily-named flag on the scoped spy network
set_spynetwork_flag = <key> (note: one can use e.g. my_flag@from to track relationships between objects)
Supported Scopes: spy_network

set_espionage_asset_flag - Sets an arbitrarily-named flag on the scoped espionage asset
set_espionage_asset_flag = <key> (note: one can use e.g. my_flag@from to track relationships between objects)
Supported Scopes: espionage_asset

remove_army_flag - Removes a flag from the scoped army
remove_army_flag = <key> (note: one can use e.g. my_flag@from to track relationships between objects)
Supported Scopes: army

remove_deposit_flag - Removes a flag from the scoped deposit
remove_deposit_flag = <key> (note: one can use e.g. my_flag@from to track relationships between objects)
Supported Scopes: deposit

remove_war_flag - Removes a flag from the scoped war
remove_war_flag = <key> (note: one can use e.g. my_flag@from to track relationships between objects)
Supported Scopes: war

remove_starbase_flag - Removes a flag from the scoped starbase
remove_starbase_flag = <key> (note: one can use e.g. my_flag@from to track relationships between objects)
Supported Scopes: starbase

remove_sector_flag - Removes a flag from the scoped sector
remove_sector_flag = <key> (note: one can use e.g. my_flag@from to track relationships between objects)
Supported Scopes: sector

remove_archaeology_flag - Removes a flag from the scoped arc site
remove_archaeology_flag = <key> (note: one can use e.g. my_flag@from to track relationships between objects)
Supported Scopes: archaeological_site

remove_spynetwork_flag - Removes a flag from the scoped spy network
remove_spynetwork_flag = <key> (note: one can use e.g. my_flag@from to track relationships between objects)
Supported Scopes: spy_network

remove_espionage_asset_flag - Removes a flag from the scoped espionage asset
remove_espionage_asset_flag = <key> (note: one can use e.g. my_flag@from to track relationships between objects)
Supported Scopes: espionage_asset

set_spawn_system_batch - Optimizes the calls for spawn_system effect. Spawn system should be located in a block between Begin and End.
Begin: set_spawn_system_batch = begin
End: set_spawn_system_batch = end
Supported Scopes: all

spawn_system - Spawns a new system at a position relative to the scoped system/planet/ship.
spawn_system = { min_jumps = <value> max_jumps = <value> min_distance = <int 0-100> max_distance = <int 0-100> initializer = <key for pre-defined system>/random hyperlane=<yes/no> is_discovered=<yes/no>}
Supported Scopes: megastructure planet ship fleet galactic_object starbase no_scope

create_nebula - Creates a new Nebula with a given radius centered around the current system.
create_nebula = {
	name = <name> (loc synced, optional - default is random)
	radius = 100
	effect = { <effects on every system in the new nebula> }
}
Supported Scopes: galactic_object

dismantle - Dismantles the scoped orbital station (fleet)
dismantle = yes
Supported Scopes: fleet

set_advisor_active - Enables or disables the VIR window pop-in
set_advisor_active = no
Supported Scopes: country

save_event_target_as - Saves the current scope as an arbitrarily-named target to be referenced later in the (unbroken) event chain
save_event_target_as = <string>/<string@scope>
Supported Scopes: all

save_global_event_target_as - Saves the current scope as an arbitrarily-named target to be referenced later, accessible globally until cleared
save_global_event_target_as = <string>/<string@scope>
Supported Scopes: all

clear_global_event_target - Deletes the specified saved global target reference
clear_global_event_target = <string>/<string@scope>
Supported Scopes: all

clear_global_event_targets - Deletes all saved global target references
clear_global_event_targets = yes
Supported Scopes: all

store_country_backup_data - Stores a copy of the specified data of the scoped country. The values default to 'no'.
store_country_backup_data = {
flag = <yes/no>
room = <yes/no>
name = <yes/no
ethics = <yes/no>
government = <yes/no>
}
Supported Scopes: country

restore_country_backup_data - Restores backed up data to the scoped country.
See store_country_backup_data for what data can be backed up.
restore_country_backup_data = <yes/no>
Supported Scopes: country

break - Prevents execution of subsequent effects in the same effect block, used with if-statements
break = yes
Supported Scopes: all

set_tutorial_level - Changes the scoped country's tutorial level (0 none, 1 limited, 2 full)
set_tutorial_level = 0
Supported Scopes: country

begin_event_chain - Starts a situation log event chain for target country
begin_event_chain = { event_chain = <key> target = <target> }
Supported Scopes: all

end_event_chain - Ends a specific situation log event chain for the scoped country
end_event_chain = <key>
Supported Scopes: country

queue_actions - Adds actions to the scoped fleet's action queue
queue_actions = { repeat = { <fleet actions> } }
Supported Scopes: fleet

clear_fleet_actions - Clears all queued fleet actions for target fleet
clear_fleet_actions = <target>
Supported Scopes: fleet

destroy_fleet - Destroys the target fleet (with death graphics)
destroy_fleet = <target>
destroy_fleet = {
	target=<target>
	kill_leader=<yes/no> #default yes
	destroy_template=<yes/no> #default no
}
Supported Scopes: all

destroy_and_spawn_debris_for - Sets the current ship or fleet to be destroyed and spawn a debris project for the specified country.
destroy_and_spawn_debris_for = from
Supported Scopes: ship fleet

create_ambient_object - Creates a new ambient object
create_ambient_object = { type = <key> location = <target> }
For VFX use:
create_ambient_object = {
	type = <key>
	scale = <float>
	location = <target>
	use_3d_location = <bool, use 3D entity or 2D coordinate of the location entity as base>
	entity_offset = {
		min = <int>
		max = <int>
	}
	entity_offset_angle = {
		min = <int>
		max = <int>
	}
	entity_offset_height = {
		min = <int>
		max = <int>
	}
	entity_face_object = star/FROM/etc
	entity_scale_to_size = yes/no
	play_animation_once = yes/no
	target = <target>
	duration = <int, days>
}
Supported Scopes: all

destroy_ambient_object - Destroys target ambient object
destroy_ambient_object = <target>
Supported Scopes: all

add_trait - Adds a specific trait to the scoped leader or a random common/negative trait 
add_trait = <trait/random_common/random_negative>
Supported Scopes: leader

add_trait_no_notify - Adds a specific trait to the scoped leader or a random common/negative trait 
add_trait_no_notify = <trait/random_common/random_negative>. Does not give a notification.
Supported Scopes: leader

remove_trait - Removes a specific trait from the scoped leader, or removes all negative traits
remove_trait = <key/all_negative>
Supported Scopes: leader

remove_all_negative_traits - Removes all negative traits from the scoped leader
remove_all_negative_traits = yes
Supported Scopes: leader

remove_all_positive_traits - Removes all non-negative traits from the scoped leader
remove_all_positive_traits = yes
Supported Scopes: leader

remove_all_traits - Removes all traits from the scoped leader
remove_all_traits = yes
Supported Scopes: leader

modify_species - Creates a new, modified species based on an already-extant species
modify_species = {
	species = <target> # species to modify
	base = <target>/auto/none # new base species; default: auto (uses species)
	add_trait = <key> # optional, can specify multiple
	remove_trait = <key> # optional, can specify multiple
	add_traits_at_start_of_list = yes # optional, pushes out other traits if needed
	ideal_planet_class = <target or pc_name> # optional
	change_scoped_species = yes/no # modify scoped pop group/planet/leader/country; default: yes
	portrait = <target or portrait name> # optional
	effect = { SCOPE_SPECIES } # optional effect to run on the resulting new species, is executed after any handling of change_scoped_species
}
Supported Scopes: planet country pop pop group leader species

add_opinion_modifier - Adds a specific opinion modifier for the scoped country towards target country
add_opinion_modifier = { modifier = <key> who = <target> }
Supported Scopes: country

establish_contact - Establishes first contact between the scoped country and target country at the set location
establish_contact = { who = <target> location = <target> }
Supported Scopes: country

set_hostile - Sets the target country as hostile. This will work on countries you don't have comms with, unlike set_faction_hostility.
set_hostile = from
Supported Scopes: country

set_faction_hostility - Sets the aggro state of the scoped faction-type country
set_faction_hostility = { target = country set_hostile = yes set_neutral = no set_friendly = no }
Supported Scopes: country

set_market_leader - Set scoped country as the current Galactic Market leader.
set_market_leader = <yes/no> 
Supported Scopes: country

add_event_chain_counter - Increments (or decrements with negative values) an event chain counter for the scoped country by a specific amount
add_event_chain_counter = { event_chain = <key> counter = <key> amount = <int>/<variable> }
Supported Scopes: country

add_anomaly - Adds a specific anomaly category to the scoped planet
add_anomaly = {
	category = <key>
	target = target:country
}
Supported Scopes: all

set_disable_at_health - Sets the scoped ship to become disabled at a certain hull point percentage
set_disable_at_health = <0-1 float>
Supported Scopes: ship

remove_building - Removes a single instance of a specific building from the scoped planet
remove_building = <key>
Supported Scopes: planet

change_planet_size - Increases or reduces the size of the scoped planet by a specified amount
change_planet_size = <+/- int>
Supported Scopes: planet

set_policy_cooldown - Sets the specified policy group to have a cooldown as if the policy had just been changed.
set_policy_cooldown = <policy group e.g. diplomatic_stance>
Supported Scopes: country

reset_policy_cooldowns - Resets the cooldown period of all policies for a country
reset_policy_cooldowns = yes
Supported Scopes: country

create_point_of_interest - Creates a point of interest for the scoped country at a specific location, associated with an event chain
create_point_of_interest = { id = <key> name = <string> desc = <string> event_chain = <key> location = <target> }
Supported Scopes: planet country ship pop pop group

remove_point_of_interest - Removes a specific point of interest from the scoped country's situation log
remove_point_of_interest = <key>
Supported Scopes: country

set_relation_flag - Sets a relation flag for the scoped country towards target country
set_relation_flag = {
	who = <target>
	flag = <key> (note: one can use e.g. my_flag@from to track relationships between objects)
}
Supported Scopes: country

remove_relation_flag - Removes a specific relation flag towards target country from the scoped country
remove_relation_flag = {
	who = <target>
	flag = <key> (note: one can use e.g. my_flag@from to track relationships between objects)
}
Supported Scopes: country

kill_leader - Kills the scoped leader or leader of the scoped country/fleet/ship/planet/army/first contact system/spy network
kill_leader = {
	class = <key, optional, if left out will kill scoped leader, can be used multiple times>
	ability = <key, optional, see leader class for list of abilities, will kill leader that has this ability, can be used multiple times>

	show_notification = <yes/no>
	heir = <yes, optional, if added to type = ruler, will kill heir instead>
	fire = yes (default: no; if yes, fires on_leader_fired instead of on_leader_death
}
Supported Scopes: planet country ship fleet leader army

assign_leader - Assigns target leader to the scoped country/fleet/army/
assign_leader = <target>
Supported Scopes: planet country fleet army

set_years_served - Copies years served duration from the target
set_years_served = <target>
Supported Scopes: leader

country_add_ethic - Adds a specific ethic to the scoped country
country_add_ethic = <key>
Supported Scopes: country

country_remove_ethic - Removes a specific ethic from the scoped country
country_remove_ethic = <key>
Supported Scopes: country

set_timed_first_contact_flag - Sets an arbitrarily-named flag on the scoped first contact site for a set duration
set_timed_first_contact_flag = {
	flag = <key> (note: one can use <key>@scope e.g. my_flag@from to track relationships between objects)
	days/months/years = <int>/<variable>
}
Supported Scopes: first_contact

set_timed_situation_flag - Sets an arbitrarily-named flag on the scoped situation for a set duration
set_timed_situation_flag = {
	flag = <key> (note: one can use <key>@scope e.g. my_flag@from to track relationships between objects)
	days/months/years = <int>/<variable>
}
Supported Scopes: situation

set_timed_agreement_flag - Sets an arbitrarily-named flag on the scoped agreement for a set duration
set_timed_agreement_flag = {
	flag = <key> (note: one can use <key>@scope e.g. my_flag@from to track relationships between objects)
	days/months/years = <int>/<variable>
}
Supported Scopes: agreement

set_timed_federation_flag - Sets an arbitrarily-named flag on the scoped federation for a set duration
set_timed_federation_flag = {
	flag = <key> (note: one can use <key>@scope e.g. my_flag@from to track relationships between objects)
	days/months/years = <int>/<variable>
}
Supported Scopes: federation

set_timed_country_flag - Sets an arbitrarily-named flag on the scoped country for a set duration
set_timed_country_flag = { 
	flag = <key> (note: one can use <key>@scope e.g. my_flag@from to track relationships between objects)
	days/months/years = <int>/<variable>
}
Supported Scopes: country

set_timed_fleet_flag - Sets an arbitrarily-named flag on the scoped fleet for a set duration
set_timed_fleet_flag = {
	flag = <key> (note: one can use <key>@scope e.g. my_flag@from to track relationships between objects)
	days/months/years = <int>/<variable>
}
Supported Scopes: fleet

set_timed_global_flag - Sets an arbitrarily-named global flag for a set duration
set_timed_global_flag = {
	flag = <key> (note: one can use <key>@scope e.g. my_flag@from to track relationships between objects)
	days/months/years = <int>/<variable>
}
Supported Scopes: all

set_timed_planet_flag - Sets an arbitrarily-named flag on the scoped planet for a set duration
set_timed_planet_flag = { 
	flag = <key> (note: one can use <key>@scope e.g. my_flag@from to track relationships between objects)
	days/months/years = <int>/<variable>
}
Supported Scopes: planet

set_timed_pop_flag - Sets an arbitrarily-named flag on the scoped pop for a set duration
set_timed_pop_flag = {
	flag = <key> (note: one can use <key>@scope e.g. my_flag@from to track relationships between objects)
	days/months/years = <int>/<variable>
}
Supported Scopes: pop

set_timed_pop_group_flag - Sets an arbitrarily-named flag on the scoped pop group for a set duration
set_timed_pop_group_flag = {
	flag = <key> (note: one can use <key>@scope e.g. my_flag@from to track relationships between objects)
	days/months/years = <int>/<variable>
}
Supported Scopes: pop group

set_timed_relation_flag - Sets an arbitrarily-named flag for the scoped country towards target country for a set duration
set_timed_relation_flag = {
	flag = <key> (note: one can use <key>@scope e.g. my_flag@from to track relationships between objects)
	who = <target>
	days/months/years = <int>
}
Supported Scopes: country

set_timed_ship_flag - Sets an arbitrarily-named flag on the scoped ship for a set duration
set_timed_ship_flag = {
	flag = <key> (note: one can use <key>@scope e.g. my_flag@from to track relationships between objects)
	days/months/years = <int>/<variable>
}
Supported Scopes: ship

set_timed_star_flag - Sets an arbitrarily-named flag on the scoped system for a set duration
set_timed_star_flag = { 
	flag = <key> (note: one can use <key>@scope e.g. my_flag@from to track relationships between objects)
	days/months/years = <int>/<variable>
Supported Scopes: galactic_object

set_timed_army_flag - Sets an arbitrarily-named flag on the scoped army for a set duration
set_timed_army_flag = { 
	flag = <key> (note: one can use <key>@scope e.g. my_flag@from to track relationships between objects)
	days/months/years = <int>/<variable>
}
Supported Scopes: army

set_timed_deposit_flag - Sets an arbitrarily-named flag on the scoped deposit for a set duration
set_timed_deposit_flag = { 
	flag = <key> (note: one can use <key>@scope e.g. my_flag@from to track relationships between objects)
	days/months/years = <int>/<variable>
}
Supported Scopes: deposit

set_timed_war_flag - Sets an arbitrarily-named flag on the scoped war for a set duration
set_timed_war_flag = { 
	flag = <key> (note: one can use <key>@scope e.g. my_flag@from to track relationships between objects)
	days/months/years = <int>/<variable>
}
Supported Scopes: war

set_timed_starbase_flag - Sets an arbitrarily-named flag on the scoped starbase for a set duration
set_timed_starbase_flag = { 
	flag = <key> (note: one can use <key>@scope e.g. my_flag@from to track relationships between objects)
	days/months/years = <int>/<variable>
}
Supported Scopes: starbase

set_timed_sector_flag - Sets an arbitrarily-named flag on the scoped sector for a set duration
set_timed_sector_flag = { 
	flag = <key> (note: one can use <key>@scope e.g. my_flag@from to track relationships between objects)
	days/months/years = <int>/<variable>
}
Supported Scopes: sector

set_timed_archaeology_flag - Sets an arbitrarily-named flag on the scoped arc site for a set duration
set_timed_archaeology_flag = { 
	flag = <key> (note: one can use <key>@scope e.g. my_flag@from to track relationships between objects)
	days/months/years = <int>/<variable>
}
Supported Scopes: archaeological_site

set_timed_spynetwork_flag - Sets an arbitrarily-named flag on the scoped spy network for a set duration
set_timed_spynetwork_flag = { 
	flag = <key> (note: one can use <key>@scope e.g. my_flag@from to track relationships between objects)
	days/months/years = <int>/<variable>
}
Supported Scopes: spy_network

set_timed_espionage_asset_flag - Sets an arbitrarily-named flag on the scoped espionage asset for a set duration
set_timed_espionage_asset_flag = { 
	flag = <key> (note: one can use <key>@scope e.g. my_flag@from to track relationships between objects)
	days/months/years = <int>/<variable>
}
Supported Scopes: espionage_asset

set_saved_date - Sets an arbitrarily-named date flag for the scoped object. Acts both as an <scope object>_flag and as a means for saving a date. The flag can then be referred to in localisations [This.<flag>] to produce the date.
set_saved_date = {
	key = <key> (refer to this in locs; note: this is actually a <country/whatever>_flag)
	days_from_present = <int>/<variable> (time until the date you wish to save)
	expires = <int>/<variable> (time until the saved date is cleared, default is never)
}
Supported Scopes: megastructure planet country ship pop pop group fleet galactic_object leader army ambient_object species bypass pop_faction war federation starbase deposit sector archaeological_site first_contact spy_network espionage_operation espionage_asset agreement situation astral_rift

remove_modifier - Removes a specific modifier from the scope object
remove_modifier = <key>
Supported Scopes: megastructure planet country ship pop pop group fleet galactic_object pop_faction federation starbase spy_network espionage_operation astral_rift cosmic_storm_influence_field

add_ship_design - Adds a specific ship design to the scoped country
add_ship_design = <target/last_created_design>
Supported Scopes: country

add_mission_progress - Adds or subtracts progress to/from the scoped observation post's current mission
add_mission_progress = <+/- float>
Supported Scopes: fleet

create_army_transport - Creates a new army in a new transport ship
create_army_transport = {
	ship_name = <string>
	graphical_culture = <key>
	army_name = <string>
	army_type = <key>
	species = <target>
}
Supported Scopes: fleet

switch - Executes the first appropriate effect set for a specific trigger
switch = {
	trigger = <trigger>
	<corresponding key/bool/int> = { <effect> }
	<corresponding key/bool/int> > (less/greater than appear 'reversed') { <effect> }
	default = { <effect> }
}
Supported Scopes: all

set_pop_faction - Sets the scoped pop group to belong to a specific pop faction
set_pop_faction = <target>
Supported Scopes: pop pop group

set_graphical_culture - Sets the scoped object's graphical culture
set_graphical_culture = <key>
Supported Scopes: megastructure country

set_formation_scale - Scales the scoped fleet's formation's ship spacing, above and below 1.0
set_formation_scale = <float>
Supported Scopes: fleet

set_controller - Instantly sets the planet/fleet's controller to target country
set_controller = <target>
Supported Scopes: planet fleet

force_faction_evaluation - Forces target pop to immediately evaluate their attraction to various pop factions
force_faction_evaluation = yes
Supported Scopes: pop

enable_faction_of_type - Forces scoped country to evaluate whether to create a specific faction type immediately, rather than monthly
enable_faction_of_type = <key>
Supported Scopes: country

clear_uncharted_space - Clears uncharted space from the galaxy map for the scoped country, in a radius around target system
clear_uncharted_space = <target>
Supported Scopes: country

establish_communications - Establish communications between scoped country and target country
establish_communications = <target>
Supported Scopes: country

add_monthly_resource_mult - Adds a lump sum of a resource to the scoped country, defined as a multiple of the country's monthly income of that resource (clamped to max and min allowed values)
add_monthly_resource_mult = { resource = <key> value = <float> max = <max cap, int> min = <min cap, int> mult = <variable> }
Supported Scopes: country

set_leader_flag - Sets an arbitrarily-named flag on the scoped leader
set_leader_flag = <key> (note: one can use e.g. my_flag@from to track relationships between objects)
Supported Scopes: leader

remove_leader_flag - Removes a flag from the scoped leader
remove_leader_flag = <key> (note: one can use e.g. my_flag@from to track relationships between objects)
Supported Scopes: leader

add_research_option - Adds a tech research option to the scoped country's tech view list, permanent until researched
add_research_option = <key>
Supported Scopes: country

set_heir - Sets the target leader to be the scoped country's heir
set_heir = <target>
Supported Scopes: country

leave_alliance - Removes scoped country from any alliances it is in
leave_alliance = {
	override_requirements = yes/no (default: no)
	apply_opinion_penalty = yes (default: no; sets whether 'Broke Federation' opinion is applied)
}
Supported Scopes: country

set_policy - Sets a policy to a specific option for the scoped country and specifies if policy cooldown should go into effect
set_policy = { policy = <key> option = <key> cooldown = <bool> }
Supported Scopes: country

recruitable - Sets scoped leader as non/recruitable
recruitable = yes
Supported Scopes: leader

closest_system - Executes enclosed effects on a system -within a specific number of jumps span- that meets the limit criteria. This completely ignores bypasses (wormholes and gateways)
closest_system = {
	min_steps = <int, minimum # of systems 'away'>
	max_steps = <int, maximum # of systems 'away'>
	use_bypasses = yes/no (default: no)
	limit = { <triggers> }
	<effects>
}
Supported Scopes: all

set_ambient_object_flag - Sets an arbitrarily-named flag on the scoped ambient object
set_ambient_object_flag = <key> (note: one can use e.g. my_flag@from to track relationships between objects)
Supported Scopes: ambient_object

set_timed_ambient_object_flag - Sets an arbitrarily-named flag on the scoped ambient object for a set duration
set_timed_ambient_object_flag = {
	flag = <key> (note: one can use <key>@scope e.g. my_flag@from to track relationships between objects)
	days/months/years = <int>/<variable>
}
Supported Scopes: fleet

remove_ambient_object_flag - Removes a flag from the scoped ambient object
remove_ambient_object_flag = <key> (note: one can use e.g. my_flag@from to track relationships between objects)
Supported Scopes: ambient_object

set_aggro_range - Sets the scoped fleet/country's aggro range in intra-system units
set_aggro_range = <int>
Supported Scopes: country fleet

set_fleet_stance - Sets the stance of the scoped fleet
set_fleet_stance = <key, aggressive/passive/evasive>
Supported Scopes: fleet

add_favors - Add <value> favors for scoped country to use on target country.
add_favor = {
	target = <target>
	value = 2/variable
}
Supported Scopes: country

remove_favors - Remove <value/all> favors that scoped country have on target country:
remove_favors = {
target = <target>
value = <value/all/variable> }
Supported Scopes: country

set_aggro_range_measure_from - Determines whether the scoped fleet/country's aggro range is measured from the fleet's current position or its spawn location
set_aggro_range_measure_from = <key, self/return_point>
Supported Scopes: country fleet

establish_communications_no_message - Silently establish communications between scoped country and target country
establish_communications_no_message = <target>
Supported Scopes: country

remove_war_participant - Removes a specified country from the war
remove_war_participant = <target>
Supported Scopes: war

set_subject_of - Sets the scoped country to be a subject of target country. If use_demanded_terms is set to yes, then the subject agreement will use terms that have previously been demanded in a diplomatic action. If allow_instant_negotiation is set to yes, then the subject and overlord can re-negotiate their agreement right away without having to way for the cooldown. If preset is specified, then the agreement will start as that preset
set_subject_of = { who = <target>
use_demanded_terms = yes
allow_instant_negotiation = yes
preset = <preset_name> [optional] }
Supported Scopes: country

unassign_leader - Unassigns scoped leader from their post or unassigns leader from the scoped planet/ship/fleet/army
unassign_leader = <target>
Supported Scopes: ship fleet leader army

exile_leader_as - Exiles the scoped country/fleet/army/leader and saves them with a custom name
exile_leader_as = <key>/<key@scope>
Supported Scopes: country fleet leader army

set_leader - Reinstates a previously-exiled leader to the scoped country/fleet/army/pop faction
set_leader = <key>/<key@scope>
Supported Scopes: country fleet army

add_skill - Adds to the scoped leader's skill level
add_skill = 2
Supported Scopes: leader

set_skill - Sets the scoped leader's level
set_skill = 3
Supported Scopes: leader

set_federation_leader - Sets a country to lead a federation
set_federation_leader = <target>
Supported Scopes: country federation

add_colony_progress - Adds to ongoing colonization progress on the scoped planet
add_colony_progress = <0.0-1.0>
Supported Scopes: planet

start_colony - Starts colonization of the scoped planet
start_colony = {
	owner = <target>
	species = <target / key>
	ethos = <random / target / { ethic = <key> ethic = <key> }>
}
Supported Scopes: planet

subtract_variable - Decrements a previously-set variable by a specific amount
subtract_variable = { which = <string> value = <float>/<variable>/<scope.variable>/trigger:<trigger> }
Supported Scopes: megastructure planet country ship pop pop group fleet galactic_object leader army ambient_object species bypass pop_faction war federation starbase deposit sector archaeological_site first_contact spy_network espionage_operation espionage_asset agreement situation astral_rift

multiply_variable - Multiplies a previously-set variable by a specific amount
multiply_variable = { which = <string> value = <float>/<variable>/<scope.variable>/trigger:<trigger> }
Supported Scopes: megastructure planet country ship pop pop group fleet galactic_object leader army ambient_object species bypass pop_faction war federation starbase deposit sector archaeological_site first_contact spy_network espionage_operation espionage_asset agreement situation astral_rift

divide_variable - Divides a previously-set variable by a specific amount
divide_variable = { which = <string> value = <float>/<variable>/<scope.variable>/trigger:<trigger> }
Supported Scopes: megastructure planet country ship pop pop group fleet galactic_object leader army ambient_object species bypass pop_faction war federation starbase deposit sector archaeological_site first_contact spy_network espionage_operation espionage_asset agreement situation astral_rift

modulo_variable - Modulos a previously-set variable by a specific amount i.e. X % Y
modulo_variable = { which = <string> value = <float>/<variable>/<scope.variable>/trigger:<trigger> }
Supported Scopes: megastructure planet country ship pop pop group fleet galactic_object leader army ambient_object species bypass pop_faction war federation starbase deposit sector archaeological_site first_contact spy_network espionage_operation espionage_asset agreement situation astral_rift

round_variable_to_closest - Rounds a previously-set variable to the closest X
round_variable_to_closest = {
	which = <string>
	value = <float>/<variable>/<scope.variable>/trigger:<trigger> (variable will be rounded to a multiple of this value)
}
Supported Scopes: megastructure planet country ship pop pop group fleet galactic_object leader army ambient_object species bypass pop_faction war federation starbase deposit sector archaeological_site first_contact spy_network espionage_operation espionage_asset agreement situation astral_rift

play_sound - Play the defined sound effect
play_sound = myfirstsoundeffect
Supported Scopes: all

set_crisis_sound - Sets the crisis ambient loop to the current effect
set_crisis_sound = myfirstsoundeffect
Supported Scopes: all

stop_crisis_sound - Stops the crisis ambient loop
stop_crisis_sound = yes
Supported Scopes: all

multiply_crisis_strength - Multiplies crisis strength by this factor.
multiply_crisis_strength = 1.5
Supported Scopes: all

force_add_civic - Adds civic to a government without checking the restrictions
force_add_civic = <civic>
Supported Scopes: country

force_remove_civic - Removes civic from a government without checking the restrictions
force_remove_civic = <civic>/2
Supported Scopes: country

set_origin - Sets the country's origin to a certain value. Note: This will not run effects executed during galaxy generation.
set_origin = <origin>
Supported Scopes: country

set_gender - Sets the gender of the scoped leader
set_gender = female
Supported Scopes: leader

copy_flags_and_variables_from - Copies all script flags and variables from the specified scope to the current one.
copy_flags_and_variables_from = event_target:them
Supported Scopes: all

reroll_random - Rerolls the random seed. Use if you want to have a second random_list return a different result. Do not use in tooltips that show random results, because the tooltip will be wrong!
reroll_random = yes
Supported Scopes: all

create_fleet_from_naval_cap - Creates a new fleet from empire designs up to specified fraction of naval cap
create_fleet_from_naval_cap = 0.5
create_fleet_from_naval_cap = { fraction = 0.5 ship_owner_type = <country/federation/galactic_community>
Supported Scopes: country

remove_opinion_modifier - Removes a specific opinion modifier towards target country or any country from the scoped country
remove_opinion_modifier = { modifier = <key> who = <target (optional)> }
Supported Scopes: country

set_war_goal - Sets a war goal to the scoped rebel country/war
set_war_goal = { type = <key> target = <target> enemy = <target> }
Supported Scopes: country war

change_country_flag - Changes the scoped country's flag
change_country_flag = random
change_country_flag = { icon = { category = <key> file = <filename> } background = { category = <key> file = <filename> } colors = { <key> <key> } }
Supported Scopes: country

add_threat - Adds diplomatic threat from target country
add_threat = { who = <country> amount = 4/variable }
Supported Scopes: planet country galactic_object

set_mission - Sets the current mission of an observation station
set_mission = passive_observation
Supported Scopes: fleet

change_dominant_species - Changes the dominant species of the current Country, change_all also changes all usage of that species (Pops etc) in the empire
change_dominant_species = { species = target change_all = yes }
Supported Scopes: country

end_rivalry - Force-end rivalry with target country
end_rivalry = <target>
Supported Scopes: country

set_truce - Force a truce with target country of a specified type, or a war
set_truce = { target = <country/war> type = war/liberation/alliance/guarantee/none }
Supported Scopes: country

end_truce - Force-end truce with target country
end_truce = <target>
Supported Scopes: country

set_species_flag - Sets an arbitrarily-named flag on the scoped species
set_species_flag = <key> (note: one can use <key>@scope e.g. my_flag@from to track relationships between objects)
Supported Scopes: species

set_timed_species_flag - Sets an arbitrarily-named flag on the scoped species for a set duration
set_timed_species_flag = { 
	flag = <key> (note: one can use <key>@scope e.g. my_flag@from to track relationships between objects)
	days/months/years = <int>/<variable>
}
Supported Scopes: species

remove_species_flag - Removes a flag from the scoped species
remove_species_flag = <key> (note: one can use <key>@scope e.g. my_flag@from to track relationships between objects)
Supported Scopes: species

auto_move_to_planet - Makes a fleet or ship auto-move to target planet
auto_move_to_planet = { target = <planet> clear_auto_move_on_arrival = yes }
Supported Scopes: ship fleet

remove_auto_move_target - Makes a fleet or ship stop auto-moving
remove_auto_move_target = yes
Supported Scopes: ship fleet

auto_follow_fleet - Makes a fleet or ship auto-move to target fleet and potentially attack it
auto_follow_fleet = { target = <fleet> attack_fleet = yes }
Supported Scopes: ship fleet

set_closed_borders - Changes closed borders status between two countries
set_closed_borders = {
	who = target
	status = yes/no
	forced = <int>/<variable> (number of years)
}
Supported Scopes: country

repair_percentage - Restores a certain percentage of hull points to the scoped ship
repair_percentage = 0.1
Supported Scopes: ship fleet

repair_armor_percentage - Restores a certain percentage of armor points to the scoped ship
repair_armor_percentage = 0.1
Supported Scopes: ship fleet

endgame_telemetry - Send endgame telemetry event
endgame_telemetry = ai_revolt
Supported Scopes: all

set_deposit - Replaces resource deposit on the scoped planet
set_deposit = <key/random>
Supported Scopes: planet

randomize_flag_symbol - Randomizes a country's flag symbol within the selected category
randomize_flag_symbol = pirate
Supported Scopes: country

add_claims - Adds claims on target system
add_claims = { who = <country> num_of_claims = x show_notification = no }
Supported Scopes: galactic_object

remove_claims - Removes claims on target system
remove_claims = { who = <country> num_of_claims = x }
Supported Scopes: galactic_object

create_military_fleet - Creates a military fleet with the designs of a specified country.
create_military_fleet = { owner = <target> scaled_size = 1.0 effect = { } }
Supported Scopes: all

guarantee_country - Makes a country guarantee another country
guarantee_country = <target>
guarantee_country = { target = <target> }
Supported Scopes: country

set_species_homeworld - Defines a homeworld for the current species.
set_species_homeworld = <target planet>
Supported Scopes: species

clear_resources - Clears resources of a country
clear_resources = yes
Supported Scopes: country

reroll_planet_modifiers - Rebuild modifiers on target planet
reroll_planet_modifiers = yes
Supported Scopes: planet

reroll_deposits - Rebuild resource deposits on target planet
reroll_deposits = yes
Supported Scopes: planet

delete_fleet - Deletes the target fleet (no death graphics)
delete_fleet = <target>
delete_fleet = {
	target=<target>
	kill_leader=<yes/no> #default yes
	destroy_template=<yes/no> #default no
}
Supported Scopes: all

delete_dimensional_fleet - Deletes the target dimensional fleet
delete_dimensional_fleet = <target>
delete_dimensional_fleet = {
	target=<target>
}
Supported Scopes: all

add_trust - Adds trust on scope country towards target country
add_trust = { amount = <amount>/<variable> who = <target> }
Supported Scopes: country

add_tradition - Adds the specified tradition to the scoped country.
add_tradition = <tradition_key>
Supported Scopes: country

join_war - Joins wars on the side of target country
join_war = <target>
Supported Scopes: country

add_global_ship_design - Adds a specific global design to the game
add_global_ship_design = <target>
Supported Scopes: all

set_timed_leader_flag - Sets an arbitrarily-named flag on the scoped leader for a set duration
set_timed_leader_flag = { 
	flag = <key> (note: one can use <key>@scope e.g. my_flag@from to track relationships between objects)
	days/months/years = <int>/<variable>
}
Supported Scopes: leader

set_species_identity - Sets the current species scopes identity to match the target scopes making them evaluate as the same species in is_same_species trigger.
set_species_identity = new/<target species>
Supported Scopes: species

pop_force_add_ethic - Adds a specific ethic to the scoped pop regardless if pop-species allows ethic divergence or not. 
pop_force_add_ethic = <key>
Supported Scopes: pop

set_empire_name - Sets the name of the current Empire.
set_empire_name = "name_loc_key"
Supported Scopes: country

set_empire_flag - Sets the flag of the current Empire.
set_empire_flag = <flag>
Supported Scopes: country

set_planet_name - Sets the name of the current planet.
set_planet_name = "name"
Supported Scopes: planet

set_fleet_formation - Sets a custom fleet formation on a fleet. 
set_fleet_formation = { position = { x = 1 y = 1 } position = { x = 2 y = 1 } }
Supported Scopes: fleet

create_message - Creates a message, can take multiple variables
create_message = { type = BYPASS_EXPLORED localization = BYPASS_EXPLORED_MESSAGE days = 30 (-1 is infinite) target = root  variable = { type = name localization = SYSTEM1 scope = from } variable = { type = name localization = SYSTEM2 scope = fromfrom } }
Supported Scopes: all

set_halted - Sets the mega structure upgrade to halted status for n days. -1 days = indefinitely
set_halted = nDays
Supported Scopes: megastructure

upgrade_megastructure_to - Starts an upgrade process on a mega structure. 
upgrade_megastructure_to = <new_type>
Supported Scopes: megastructure

set_planet_entity - Change entity of a planet.
set_planet_entity = {
	entity = <name of entity>
	graphical_culture = <target or name of culture>
	picture = <picture override>
	atmosphere_color = <color from 3 components>
	atmosphere_intensity = <0.0 - 1.0>
	atmosphere_width = <0.0 - 1.0> 
}
Supported Scopes: planet

remove_planet - Removes the planet from the scope 
remove_planet = yes
Supported Scopes: planet

set_megastructure_flag - Sets an arbitrarily-named flag on the scoped mega structure
set_megastructure_flag = <key> (note: one can use e.g. my_flag@from to track relationships between objects)
Supported Scopes: megastructure

set_timed_megastructure_flag - Sets an arbitrarily-named flag on the scoped mega structure for a set duration
set_timed_megastructure_flag = {
	flag = <key> (note: one can use <key>@scope e.g. my_flag@from to track relationships between objects)
	days/months/years = <int>/<variable>
}
Supported Scopes: megastructure

remove_megastructure_flag - Removes a flag from the scoped mega structure
remove_megastructure_flag = <key> (note: one can use e.g. my_flag@from to track relationships between objects)
Supported Scopes: megastructure

destroy_ship - Destroys the target ship (with death graphics)
destroy_ship = <target>
Supported Scopes: all

delete_ship - Deletes the target ship (no death graphics)
delete_ship = <target>
Supported Scopes: all

change_species - Changes the species of the scoped object
change_species = <target>
Supported Scopes: country ship pop pop group leader army

change_leader_portrait - Changes the portrait of the leader in scope.
change_leader_portrait = <key or species event target>
Supported Scopes: leader

change_leader_class - Changes the class of the leader in scope.
change_leader_class = <leader class event target>
Supported Scopes: leader

resettle_pop - Instantly resettles pop
resettle_pop = { pop = <target pop> planet = <target planet> tile = <target tile> }
Supported Scopes: all

set_citizenship_type - Set citizenship type for scoped species/pop group/leader
set_citizenship_type = { country = <target> type = citizenship_full cooldown = yes }
Supported Scopes: pop pop group leader species

set_military_service_type - Set military service type for scoped species/pop group/leader
set_military_service_type = { country = <target> type = military_service_full cooldown = yes }
Supported Scopes: pop pop group leader species

set_purge_type - Set purge type for scoped species/pop group/leader
set_purge_type = { country = <target> type = purge_full cooldown = yes }
Supported Scopes: pop pop group leader species

set_slavery_type - Set slavery type for scoped species/pop group/leader
set_slavery_type = { country = <target> type = slavery_livestock cooldown = yes }
Supported Scopes: pop pop group leader species

set_population_controls - Set population control for scoped species/pop group/leader
set_population_controls = { country = <target> type = yes/no cooldown = yes }
Supported Scopes: pop pop group leader species

set_migration_controls - Set migration control for scoped species/pop group/leader
set_migration_controls = { country = <target> type = yes/no cooldown = yes }
Supported Scopes: pop pop group leader species

set_colonization_controls - Set colonization control for scoped species/pop group/leader
set_colonization_controls = { country = <target> type = yes/no cooldown = yes }
Supported Scopes: pop pop group leader species

set_living_standard - Set living standard for scoped species/pop group/leader
set_living_standard = { country = <target> type = living_standard_good cooldown = yes }
Supported Scopes: pop pop group leader species

shift_ethic - Shifts an empire towards a specific ethic, adjusting afterwards to keep number of ethics points consistent
shift_ethic = <key>
Supported Scopes: country

pop_change_ethic - Changes scoped pop to chosen ethic
pop_change_ethic = <key>
Supported Scopes: pop

clear_ethos - Clears all ethics of specified pop group or country
clear_ethos = yes
Supported Scopes: country pop pop group

clear_planet_modifiers - Clear modifiers on target planet
clear_planet_modifiers = yes
Supported Scopes: planet

remove_all_armies - Removes all armies on scoped planet
remove_all_armies = yes
Supported Scopes: planet

mutate_species - Randomly mutate a species.
mutate_species = yes
Supported Scopes: species

rename_species - Renames the species.
rename_species = { 
	use one of the following:
	name = "an entry within the species name database"
	name = random
	name_list = "key"
}
Supported Scopes: species

reset_years_of_peace - Resets years of peace for a country.
reset_years_of_peace = yes
Supported Scopes: country

remove_secret_fealty - Removes a secret fealty pact between the scoped subject country and the target empire
remove_secret_fealty = <target>
Supported Scopes: country

clear_relations - Clears relations between scoped and target countries
clear_relations = {
	 target = <target country>
	 relations = { <> }
 }
Supported Scopes: country

set_agreement_terms - Sets agreement terms of the agreement. Can be used to set multiple terms at once, including resource subsidies.
set_agreement_terms = {
	subject_diplomacy = subject_can_not_do_diplomacy
	subject_integration = subject_can_be_integrated
	resource_subsidies_alloys = 0.5
}
Supported Scopes: agreement

set_agreement_preset - Sets the preset of an agreement and applies its terms on the agreement if 'apply_terms' is 'yes'.
set_agreement_preset = {
	preset = <preset key>
	apply_terms = no #Defaults to 'yes'
}
Supported Scopes: agreement

add_notification_modifier - Add a notification modifier to the country
add_notification_modifier = <key>
Supported Scopes: country

remove_notification_modifier - Remove a notification modifier to the country
remove_notification_modifier = <key>
Supported Scopes: country

set_city_graphical_culture - Sets the scoped country's city graphical culture
set_city_graphical_culture = <key>
Supported Scopes: country

set_player - Assign the player of the target country to play the scoped country instead
event_target:new_country = { set_player = event_target:old_country }
Supported Scopes: country

change_species_characteristics - Changes the characteristics of a species
change_species_characteristics = {
	sapient = <Y/N, determines if species is pre-sapient>
	immortal = <Y/N, determines if species leaders are immortal>
	can_be_modified = <Y/N, determines if the species can be modified>
	add_trait = <key> # optional, can specify multiple
	remove_trait = <key> # optional, can specify multiple
	add_traits_at_start_of_list = yes # optional, pushes out other traits if needed
	portrait = <key/species/leader event target, limits >
	gender = <any/male/female/leader event target, limits species to this gender or removes limit if 'any'>
	can_change_leader = <Y/N, apply portrait and gender (randomizes new name) changes to existing leaders> 
Supported Scopes: species

copy_techs_from - Copies all techs from the target country to the scoped country, except for some exceptions listed. Tech weights (and weight modifiers) are honoured, meaning that techs a country should not have will not be copied.
copy_techs_from = { 
	target = country
	except = { tech_1 tech_2 }
}
Supported Scopes: country

create_bypass - Creates a bypass in the parent SpatialObject (stored in FromFrom), of the type passed in "type".
create_bypass = { owner = <target> type = <bypass type> effect = { <effects> } }
Supported Scopes: megastructure

activate_gateway - Activates the gateway associated with a megastructure.
activate_gateway = <target>
Supported Scopes: all

spawn_natural_wormhole - Spawns a new natural wormhole in the scoped system.
Use in_place_of instead of orbit_X / random_pos to use the location of an existing spatial object
spawn_natural_wormhole = { bypass_type = <wormhole/sealed_wormhole> orbit_distance = 100 orbit_angle = 90 random_pos = yes/no in_place_of = <target> (optional) graphics_entity_name = <entity> (optional) }
Supported Scopes: galactic_object

link_wormholes - Link the wormhole from the scoped system to the wormhole in the target system, or from the scope wormhole to the target wormhole.
link_wormholes = from
Supported Scopes: galactic_object bypass

spawn_astral_rift - Spawns a new astral rift in the scoped system.
If the id is not set or equal to none, spawns a random rift from the pool once exploration begins.
Can be spawned relatively to an existing spatial object, tolerance is applied to the angle to avoid already existing planets.
spawn_astral_rift = { random_pos = yes/no (default = no, exclusive with relative_to and in_place_of) orbit_distance = 100 orbit_angle = 360 id = astral_rift_key/none (optional) relative_to = target (optional) tolerance = (optional) in_place_of = spatial_object (optional) graphics_entity_name = entity (optional) spawn_sound = yes/no (default = yes) init_effect = {} }
Supported Scopes: galactic_object

destroy_astral_rift - Destroys target Astral Rift
destroy_astral_rift = <target>
Supported Scopes: all

create_starbase - Creates a starbase in orbit of the star of the scoped galactic object
create_starbase = {
	owner = <target>
	size = <ship_size>
	module = <starbase_module>
	building = <starbase_building>
	effect = { ... }
}
Supported Scopes: planet galactic_object

set_starbase_size - Sets the ship size of a starbase
set_starbase_size = <ship_size>
Supported Scopes: starbase

set_starbase_module - Sets a module in a slot on a starbase
set_starbase_module = { slot = <int> module = <starbase_module> }
Supported Scopes: starbase

set_starbase_building - Sets a building in a slot on a starbase
set_starbase_building = { slot = <int> building = <starbase_building> }
Supported Scopes: starbase

remove_starbase_module - Removes a module from a certain slot or all slots on a starbase
remove_starbase_module = { slot = <int> (optional, default = all) module = <starbase_module> (optional) }
Supported Scopes: starbase

remove_starbase_building - Remove a building from a certain slot or all slots on a starbase
remove_starbase_building = { slot = <int> (optional, default = all) building = <starbase_building> (optional) }
Supported Scopes: starbase

add_casus_belli - Adds a Casus Belli to the scoped country against the target country.
add_casus_belli = { type = cb_subjugation who = <country> days = 10/variable }
Supported Scopes: country

get_galaxy_setup_value - Copies a value from the galaxy setup into a variable, optionally scaling it by an int value
get_galaxy_setup_value = { which = <string> setting = <string> [ scale_by = <float> ] }
possible values: num_empires, num_advanced_empires, num_fallen_empires, num_marauder_empires, mid_game_year, end_game_year, victory_year, num_guaranteed_colonies, num_gateways, num_wormhole_pairs, num_hyperlanes, habitable_worlds_scale, primitive_worlds_scale, crisis_strength_scale, tech_costs_scale
Supported Scopes: all

finish_upgrade - Finish the current upgrade of a Mega Structure.
finish_upgrade = yes
Supported Scopes: megastructure

effect_on_blob - Executes an effect on systems with planets owned by the scoped country, starting at an origin, and until a certain percentage of owned planets matching the planet_limit has been covered.
effect_on_blob = {
	center = <system target>
	owned_planets_percentage = 1.0/variable
	planet_limit = { <planet triggers> }
	effect = { <system effects> }
}
Supported Scopes: country

add_seen_bypass_type - Makes the scoped country remember that it has encountered the bypass type
add_seen_bypass_type = bypass_type
Supported Scopes: country

add_seen_bypass - Makes the scoped country remember that it has encountered the bypass 
add_seen_bypass = FROM
Supported Scopes: country

set_fleet_bombardment_stance - Sets the bombardment stance of the scoped fleet
set_fleet_bombardment_stance = selective
Supported Scopes: fleet

check_casus_belli_valid - Re-evaluate the specified casus belli type with given target country
check_casus_belli_valid = {
	target = none/<optional country target>
	type = <optional casus belli type>
}
Supported Scopes: country

copy_ethos_and_authority - Makes the scoped country copy the ethos and government authority of the target country.
copy_ethos_and_authority = FROM
Supported Scopes: country

clone_leader - Clones the last created leader for the scoped country
clone_leader = {
	target = <event target>
	#properties to override, see create_leader
	effect = { ... }
}
Supported Scopes: country

set_home_base - Set the home base of the scoped fleet to the specified starbase
set_home_base = event_target:cool_starbase
Supported Scopes: fleet

add_hyperlane - Adds a hyperlane between two systems
add_hyperlane = { from = <system> to = <system> }
Supported Scopes: all

remove_hyperlane - Removes existing hyperlane between two systems
remove_hyperlane = { from = <system> to = <system> }
Supported Scopes: all

else_if - Executes enclosed effects if limit criteria of preceding 'if' or 'else_if' is not met, and its own limit is met
if = { limit = { <triggers> } <effects> }
else_if = { limit = { <triggers> } <effects> }
Supported Scopes: all

create_saved_leader - Creates a new saved leader for the scoped country with a lookup key. See create_leader for parameters.
create_saved_leader = {  }
Supported Scopes: country

remove_saved_leader - Removes a saved leader for the scoped country with a lookup key
remove_saved_leader = <string>
Supported Scopes: country

activate_saved_leader - Moves a saved leader to the active for the scoped country with a lookup key
activate_saved_leader = {
	key = <string>
	add_to_owned=<yes/no> #default yes
	effect = {...}
}
Supported Scopes: country

add_relic - Adds the specified relic to the scoped country.
add_relic = <relic_key>
Supported Scopes: country

remove_relic - Removes the specified relic from the scoped country.
remove_relic = <relic_key>
Supported Scopes: country

delete_megastructure - Deletes the target mega structure (no death graphics)
delete_megastructure = <target>
Supported Scopes: all

add_random_research_option - Adds a random tech research option to the scoped country's tech view list, permanent until researched. if none applicable it runs fail_effects
add_random_research_option = {
	category = <string>
	area = <key>
	tier = <int>
	add_progress = <num>/<variable>
	ignore_prereqs = <yes/no> #default no
	ignore_rare = <yes/no> #default yes
	only_rare = <yes/no> #default no
	ignore_insight = <yes/no> #default yesyes
	fail_effects = {}
}
Supported Scopes: country

copy_random_tech_from - Adds a random tech from the target country within the given category and tech area constraints. The country must be able to research said tech (weight > 0, fulfils potential trigger)
copy_random_tech_from = {
	who = <country>
	category = computing (optional)
	area = physics (optional)
	progress = 0.5/variable (optional: this makes it grant the tech option rather than the whole tech)
}
Supported Scopes: country

add_asteroid_belt - Adds an asteroid belt at the distance in the scope.
add_asteroid_belt = {
	radius=<desired radius>
	type=<asteroid belt type key>
}
Supported Scopes: galactic_object

set_asteroid_belt - Sets an asteroid belt at the distance in the scope.
set_asteroid_belt = {
	radius=<desired radius>
	type=<asteroid belt type key>
}
Supported Scopes: galactic_object

fleet_action_research_special_project - Sends a fleet to research a special project
fleet_action_research_special_project = { special_project = test_project target = event_target:project_planet }
Supported Scopes: fleet

remove_random_district - Removes a random district from the scoped planet. Bigger district is more likely to be removed.
remove_random_district = yes
Supported Scopes: planet

remove_all_districts - Removes all districts from the scoped planet
remove_all_districts = yes
Supported Scopes: planet

remove_district - Removes a specific district from the scoped planet
remove_district = <key>
Supported Scopes: planet

add_district - Begins construction of a specific district on the scoped planet
add_district = <key>
Supported Scopes: planet

enable_on_market - Enables a resource on the Galactic Market
enable_on_market = <resource_key>
Supported Scopes: all

enable_galactic_market - Enables the galactic market.
enable_galactic_market = <yes/no> 
Supported Scopes: country

add_timed_trait - Adds a specific trait to the scoped leader for a specific duration
add_timed_trait = { trait = <trait> days/months/years = <value>/<variable> }
Supported Scopes: leader

set_planetary_ascension_tier - Sets the planet's ascension tier to the specified value
set_planetary_ascension_tier = 3
Supported Scopes: planet

create_archaeological_site - Creates a archaeological site associated with the scope object
create_archaeological_site = <site type>
Supported Scopes: megastructure planet ship fleet galactic_object ambient_object starbase debris astral_rift

destroy_archaeological_site - Destroys a archaeological site in right hand site event target
destroy_archaeological_site = <event target>
Supported Scopes: all

add_starbase_component - Adds a ship component to a starbase, standalone from any module or building
add_starbase_component = { component = <component key> }
Supported Scopes: starbase

remove_starbase_component - Removes the specified ship component to a starbase. Only works for components that are standalone from any module or building.
remove_starbase_component = { component = <component key> }
Supported Scopes: starbase

add_stage_clues - Adds clues to the current stage of an archaeological or first contact site
add_stage_clues = <int>
Supported Scopes: archaeological_site first_contact astral_rift

add_expedition_log_entry - Adds a specific expedition log entry to an archaeological site chapter
add_expedition_log_entry = {
	title = <loc key>
	tooltip = <loc key>
}
Supported Scopes: archaeological_site

reset_current_stage - Resets the current stage
reset_current_stage = yes/no
yes = also randomize new difficulty if stage allows that.
no = does not change difficulty
Supported Scopes: archaeological_site

set_current_stage - Sets the current stage for this arc site (first chapter is index 0).
set_current_stage = <stage number>
Supported Scopes: archaeological_site

finish_current_stage - Finish the current stage
finish_current_stage = yes/no/<country>
yes = trigger stage completed for each stage and current excavator.
no = do not trigger any stage completed
country = use this country instead of excavator, no stage complete will be triggered.
Supported Scopes: archaeological_site

finish_site - Finish the whole archaeological site
finish_site	 = yes/no/<country>
yes = trigger stage completed for each stage and current excavator.
no = do not trigger any stage completed
country = use this country instead of excavator, no stage complete will be triggered.
Supported Scopes: archaeological_site

set_site_progress_locked - Locks or unlocks the progress of a site
set_site_progress_locked = yes/no
Supported Scopes: archaeological_site first_contact

advanced_authority_refresh - Used after an advanced authority swap to make sure things are changed properly
advanced_authority_refresh = yes
Supported Scopes: country

custom_tooltip_with_params - Displays a specific localization string with parameters in tooltip
custom_tooltip_with_params = {
	description = <loc key>
	description_parameters = {
		<value key> = <string/int/num/bool>
	}
}
Supported Scopes: all

set_federation_law - Sets the given law for the scoped federation
set_federation_law = <federation law>
Supported Scopes: federation

add_to_galactic_community - Tries to add the scoped country to the Galactic Community
add_to_galactic_community = yes/no
Supported Scopes: country

add_to_galactic_community_no_message - Tries to add the scoped country to the Galactic Community without producing member joining notifications.
add_to_galactic_community_no_message = yes/no
Supported Scopes: country

remove_from_galactic_community - Tries to remove the scoped country from the Galactic Community
remove_from_galactic_community = yes/no
Supported Scopes: country

add_to_galactic_council - Tries to add the scoped country to the Galactic Council
add_to_galactic_council = yes/no
Supported Scopes: country

remove_from_galactic_council - Tries to remove the scoped country from the Galactic Council
remove_from_galactic_council = yes/no
Supported Scopes: country

steal_relic - Steal all/a random/a specific relic from a target country
steal_relic = { target = <Target Country> relic = <relic_name/all/random>
Supported Scopes: country

country_list_tooltip - Prints a list of the countries that match the limit triggers in a tooltip, each separated by a line break.
country_list_tooltip = { limit = { <triggers> } }
Supported Scopes: all

owned_planet_list_tooltip - Prints a list of the country's planets that match the limit triggers in a tooltip, each separated by a line break.
owned_planet_list_tooltip = { limit = { <triggers> } }
Supported Scopes: country

owned_pop_faction_list_tooltip - Prints a list of the country's pop factions that match the limit triggers in a tooltip, each separated by a line break.
owned_pop_faction_list_tooltip = { limit = { <triggers> } }
Supported Scopes: country

owned_leader_list_tooltip - Prints a list of the country's leaders that match the limit triggers in a tooltip, each separated by a line break.
owned_leader_list_tooltip = { limit = { <triggers> } }
Supported Scopes: country

owned_fleet_list_tooltip - Prints a list of the country's fleets that match the limit triggers in a tooltip, each separated by a line break.
owned_fleet_list_tooltip = { limit = { <triggers> } divider_tooltip = localisation }
Supported Scopes: country

set_cooldown - Locks the leader in its current role for the next X days.
set_cooldown = int
Supported Scopes: leader

add_federation_experience - Adds experience to the scoped federation
add_federation_experience = <federation experience>
Supported Scopes: federation

set_federation_type - Sets federation type to the scoped federation
set_federation_type = <federation type>
Supported Scopes: federation

set_federation_succession_type - Sets scoped federation's succession type to the specified value. Please don't use outside law on_enact, functional effect! Use set_federation_law and has_federation_law instead.
set_federation_succession_type = <federation succession type>
Federation succession types: strongest/diplomatic_weight/rotation/challenge/random
Supported Scopes: federation

set_federation_succession_term - Sets scoped federation's succession term to the specified value. Please don't use outside law on_enact, functional effect! Use set_federation_law and has_federation_law instead.
set_federation_succession_type = <federation succession term>
Federation succession terms: status_change/years_10/years_20/years_30/years_40
Supported Scopes: federation

set_only_leader_builds_fleets - Sets exclusive right to build fleets by federation leader. Please don't use outside law on_enact, functional effect! Use set_federation_law and has_federation_law instead.
set_only_leader_builds_fleets = <yes/no>
Supported Scopes: federation

set_allow_subjects_to_join - Sets right for subjects to join federation. Please don't use outside law on_enact, functional effect! Use set_federation_law and has_federation_law instead.
set_allow_subjects_to_join = <yes/no>
Supported Scopes: federation

set_equal_voting_power - Sets different voting weight. Please don't use outside law on_enact, functional effect! Use set_federation_law and has_federation_law instead.
set_equal_voting_power = <yes/no>
Supported Scopes: federation

set_diplomacy_action_setting - Sets diplomatic action custom setting. Please don't use outside law on_enact, functional effect! Use set_federation_law and has_federation_law instead.
set_diplomacy_action_setting = {
	action = <action_key>
	settings = { vote_type = default }
}
Supported Scopes: federation

set_free_migration - Sets unified migration flag for federation. Please don't use outside law on_enact, functional effect! Use set_federation_law and has_federation_law instead.
set_free_migration = <yes/no>
Supported Scopes: federation

set_federation_settings - Sets diplomatic action custom setting. Please don't use outside law on_enact, functional effect! Use set_federation_law and has_federation_law instead.
set_federation_settings = {
	<setting> = <value>
	...
}
Supported Scopes: federation

add_associate_member - Add specified country as an associate member
add_associate_member = { who = <target> override_requirements = yes/no }
Supported Scopes: federation

remove_associate_member - Removes a specific associate member from the federation
remove_associate_member = { who = <country> override_requirements = yes/no }
Supported Scopes: federation

add_cohesion - Add cohesion to the federation
add_cohesion = <value>
Supported Scopes: federation

set_council_size - Sets the number of seats on the Galactic Council
set_council_size = <int>
Supported Scopes: all

increase_council_size - Increases the number of seats on the Galactic Council by 1
increase_council_size = yes/no
Supported Scopes: all

decrease_council_size - Decreases the number of seats on the Galactic Council by 1
decrease_council_size = yes/no
Supported Scopes: all

set_council_veto - Sets whether council members can veto resolutions or not
set_council_veto = yes/no
Supported Scopes: all

set_council_emergency_measures - Sets whether council members can propose emergency measures or not
set_council_emergency_measures = yes/no
Supported Scopes: all

add_permanent_councillor - Gives provided country a permanent position on the Galactic Council
add_permanent_councillor = yes/no
Supported Scopes: country

remove_permanent_councillor - Remove the provided country from their permanent council position
remove_permanent_councillor = yes/no
Supported Scopes: country

add_loyalty - Add loyalty to subject of an agreement
add_loyalty = 5
Supported Scopes: agreement

set_sector_capital - Sets the scoped planet to be the capital of the sector it is part of. If used in the capital sector, it will shift the empire capital. Warning: Experimental, may have unintended consequences.
set_sector_capital = yes
Supported Scopes: planet

set_colony_type - Sets the colony's designation type
set_colony_type = <colony type>
Supported Scopes: planet

set_male_ruler_title - Sets the country's male ruler title to a custom value
set_male_ruler_title = "Grand Executioner"
Supported Scopes: country

set_female_ruler_title - Sets the country's female ruler title to a custom value
set_female_ruler_title = "Grand Executionerress"
Supported Scopes: country

set_male_heir_title - Sets the country's male heir title to a custom value
set_male_heir_title = "Little Executioner"
Supported Scopes: country

set_female_heir_title - Sets the country's female heir title to a custom value
set_female_heir_title = "Little Executioneress"
Supported Scopes: country

clear_custom_ruler_and_heir_titles - Clears all custom ruler and heir titles from the country, resetting them to default values
clear_custom_ruler_and_heir_titles = yes
Supported Scopes: country

complete_special_project - Completes a specific special project for the country, firing the on complete effects
complete_special_project = { type = <project key> location = <target> }
Supported Scopes: country

set_government_cooldown - Locks the country's government for a given period of days, the default cooldown, or unlocks it.
set_government_cooldown = 500/default/no
Supported Scopes: country

change_colony_foundation_date - Changes the colony foundation date (affecting on_colony_X_years pulses) by a specific number of days. Use with care, you can probably break things with this!
change_colony_foundation_date = <+/- int>
Supported Scopes: planet

log_error - Prints a message to error.log for debugging purposes.
Supported Scopes: all

add_intel - Adds the defined amount of intel toward the target empire
add_intel = { amount = <float>/<variable> who = <target> }
Supported Scopes: country

fire_on_action - Fires a made-up on_action.
fire_on_action = { on_action = <string> scopes = { from = X fromfrom = Y } }
Supported Scopes: all

set_first_contact_stage - Sets the given stage for the scoped first contact
set_first_contact_stage = <stage name>
Supported Scopes: first_contact

finish_current_operation_stage - Finish the current operation phase
finish_current_operation_stage = yes/no
yes = trigger stage completed for each stage and current excavator.
no = do not trigger any stage completed
Supported Scopes: espionage_operation

set_mia - Sets the current fleet to go missing in action with the MIA type defided by <key>
set_mia = <key>
Supported Scopes: fleet

set_mia_return_delay - If the scoped fleet is MIA, sets the return date in a given number of days, starting from current date
set_mia_return_delay = <int>
Supported Scopes: fleet

create_espionage_asset - Creates espionage asset within a given spy network
create_espionage_asset = {
	type = <espionage asset type>
	effect = { <effects executed on asset> }
}
Supported Scopes: spy_network

destroy_espionage_asset - Destroys espionage asset within a given spy network/operation
destroy_espionage_asset = <espionage asset type>
Supported Scopes: spy_network espionage_operation

set_espionage_operation_progress_locked - Locks or unlocks the progress of an espionage operation
set_espionage_operation_progress_locked = yes/no
Supported Scopes: espionage_operation

unassign_espionage_asset - Unassigns espionage asset from the scope operation to owning spy network
unassign_espionage_asset = <espionage asset type>
Supported Scopes: espionage_operation

assign_espionage_asset - Assigns espionage asset to the scope operation from owning spy network
assign_espionage_asset = <espionage asset type>
Supported Scopes: espionage_operation

set_espionage_operation_flag - Sets an arbitrarily-named flag on the scoped espionage operation
set_espionage_operation_flag = <key> (note: one can use e.g. my_flag@from to track relationships between objects)
Supported Scopes: espionage_operation

remove_espionage_operation_flag - Removes a flag from the scoped espionage operation
remove_espionage_operation_flag = <key> (note: one can use e.g. my_flag@from to track relationships between objects)
Supported Scopes: espionage_operation

set_design_flag - Sets an arbitrarily-named flag on the scoped design
set_design_flag = <key> (note: one can use e.g. my_flag@from to track relationships between objects)
Supported Scopes: design

remove_design_flag - Removes a flag from the scoped design
remove_design_flag = <key> (note: one can use e.g. my_flag@from to track relationships between objects)
Supported Scopes: design

complete_crisis_objective - Gives the player the reward for the specified crisis objective, if the player's selected crisis path includes it. Gives nothing if the player's crisis path doesn't include it. 
complete_crisis_objective = <objective>
Supported Scopes: country

start_situation - Begins a situations.
start_situation = { type = <situation_type> target = <scope> }
Supported Scopes: country

espionage_operation_event - Fires a espionage event event for the scoped object, with optional DAYS and RANDOM delay
espionage_operation_event = {
	id = <id>
	days = x (optional: specify delay)
	random = y (optional: specify random delay from 0 to value, which is added on to the 'days' delay)
	scopes = { from = fromfrom } (optional: specify scope overrides)
}
Supported Scopes: espionage_operation

join_war_on_side - Joins the war on the specified side.
join_war_on_side = { war = <target> side = attackers/defenders/<country> }
Supported Scopes: country

dissolve_federation - Dissolved the current federation
dissolve_federation = yes
Supported Scopes: federation

remove_random_starbase_building - Remove a number of random building(s) matching/not matching a type from the starbase
remove_random_starbase_building = {
	type = <starbase building> ( optional. default: all )
	count = <int> (optional. default: 1 )
}
Supported Scopes: starbase

remove_random_starbase_module - Remove a number of random module(s) matching/not matching a type from the starbase
remove_random_starbase_module = {
	type = <starbase module> ( optional. default: all )
	count = <int> (optional. default: 1 )
}
Supported Scopes: starbase

set_timed_espionage_operation_flag - Sets an arbitrarily-named flag on the scoped espionage operation for a set duration
set_timed_espionage_operation_flag = {
	flag = <key> (note: one can use <key>@scope e.g. my_flag@from to track relationships between objects)
	days/months/years = <int>/<variable>
}
Supported Scopes: espionage_operation

destroy_espionage_operation - Destroys a espionage operation site in right hand site event target
destroy_espionage_operation = <event target>
Supported Scopes: all

add_espionage_information - Adds information to the current stage of an espionage operation
add_espionage_information = <value>
Supported Scopes: espionage_operation

add_victory_score - Adds victory score to a country
add_victory_score = { source=<loc_key> score=<value>/<variable> }
Supported Scopes: country

activate_crisis_progression - Activates crisis progression for the country
activate_crisis_progression = <path_name>.
Supported Scopes: country

room_name_override - Sets the room background of the empire. Provide an empty string to remove the override.
room_name_override = <room_name>
Supported Scopes: country

set_ai_personality - Sets the AI personality of a country to a new one
set_ai_personality=<personality>
Supported Scopes: country

add_custodian_term_days - Increase the current Custodian term time
add_custodian_term_days = <days>
Supported Scopes: all

set_custodian_term_days - Set the current Custodian term time. -1 will make the Custodianship permanent.
set_custodian_term_days = <days>
Supported Scopes: all

destroy_situation - Destroys a situation in right hand side event target, use once situation is complete (on_fail/on_complete/on_abort is not called)
destroy_situation = <event target>
Supported Scopes: all

abort_situation - Destroys a situation in right hand side event target, firing on_abort (use to cancel and fire that effect)
abort_situation = <event target>
Supported Scopes: all

add_situation_progress - Adds a sum of progress scoped situation
add_situation_progress = 5.5
Supported Scopes: situation

set_situation_approach - Sets the approach to the Situation. Respects allow and potential triggers.
set_situation_approach = <approach> (name field of the approach)
Supported Scopes: situation

set_situation_locked - Locks the Situation so it will not progress until unlocked.
set_situation_locked = yes/no (no unlocks it)
Supported Scopes: situation

change_situation_target - Changes the target of a Situation.
change_situation_target = none/scope
Supported Scopes: situation

pass_targeted_resolution - Immediately passes the first found (oldest) proposed/voting for/failed resolution OR a new resolution of this type that has the specified target. Ignores whether the target is valid or not.
pass_targeted_resolution = { resolution = <resolution type> target = <target>
Supported Scopes: country

set_update_modifiers_batch - Disables modifier system to do full updates between Begin and End.
On end it will trigger a full update of any dirty modifiers.
Begin: set_update_modifiers_batch = begin
End: set_update_modifiers_batch = end
Supported Scopes: all

set_rule_can_subject_be_integrated - Changes the agreement term for whether the Subject can be integrated
set_rule_can_subject_be_integrated = <yes/no>
Supported Scopes: agreement

set_rule_can_subject_do_diplomacy - Changes the agreement term for whether the Subject can do diplomacy
set_rule_can_subject_do_diplomacy = <yes/no>
Supported Scopes: agreement

set_rule_can_subject_expand - Changes the agreement term for whether the Subject can expand
set_rule_can_subject_expand = <can_expand/can_expand_with_tithe/cannot_expand>
Supported Scopes: agreement

set_rule_can_subject_vote - Changes the agreement term for whether the Subject can vote independently of its overlord in GalCom/federations
set_rule_can_subject_vote = <yes/no>
Supported Scopes: agreement

set_rule_join_overlord_wars - Changes the agreement term for Subject to join Overlord wars
set_rule_join_overlord_wars = <none/defensive/offensive/all>
Supported Scopes: agreement

set_rule_join_subject_wars - Changes the agreement term for Overlord to wars of its Subject
set_rule_join_subject_wars = <none/defensive/offensive/all>
Supported Scopes: agreement

set_rule_subject_has_access - Changes the agreement term for whether the Subject can access the overlord's territory (and territories the overlord has access to) despite closed borders
set_rule_subject_has_access = <yes/no>
Supported Scopes: agreement

set_rule_subject_has_sensors - Changes the agreement term for whether the Subject gets sensors data from Overlord
set_rule_subject_has_sensors = <yes/no>
Supported Scopes: agreement

convert_to_specialist - Starts the process of converting the subject of the scoped agreement to the given specialist type.
Can also be used to remove the specialization from a subject, by using 'none' as value.
convert_to_specialist = <specialist_subject_type>
Supported Scopes: agreement

pass_debris_ownership - Passes the scoped debris ownership to the specified country 
pass_debris_ownership = { owner = <target country> }
Supported Scopes: debris

set_council_position - Sets the scoped leader to a council position if it is present in the government of the leader's owner country.
set_council_position = COUNCIL_POS_KEY
Supported Scopes: leader

set_council_position_to_council - Assigns a council position to the country's council, if possible.
set_council_position_to_council = COUNCIL_POS_KEY
Supported Scopes: country

end_fleet_contract - Breaks fleet lease contract 
end_fleet_contract = yes
Supported Scopes: fleet

set_cloaking_active - Sets current fleet's cloaking status
set_cloaking_active = yes|no
Supported Scopes: fleet

go_to_next_pre_ftl_age - Advances country to next pre-FTL technology level if possible. Does nothing if has_next_pre_ftl_age would be false, or if argument is 'no'.
go_to_next_pre_ftl_age = <yes/no>
Supported Scopes: country

set_pre_ftl_age - Set pre-FTL technology level. Does nothing if the country is not pre-FTL.
set_pre_ftl_age = <age>
Supported Scopes: country

remove_communications - Remove communications between scoped country and target country
remove_communications = <target>
Supported Scopes: country

remove_envoys_to - Removes any envoys from scoped country assigned to target country
remove_envoys_to = <country>
Supported Scopes: country

remove_from_federation - The scoped country is removed from any federation its in
remove_from_federation = yes
Supported Scopes: country

set_ship_design - Changes which design a ship uses/all ships in a fleet use, to the target design
set_ship_design = {
  design = <ship design key/target/last_created_design, or use random_existing_design>
  random_existing_design = <ship size key>
}
Supported Scopes: ship fleet

renew_bypass_lock - Renew a Bypass Lock's duration as if it was just built.
renew_bypass_lock = yes
Supported Scopes: bypass

lock_bypass - Lock a Bypass for exclusive access for a given country.
lock_bypass = { country = owner duration = 360 }
Supported Scopes: bypass

date_distortion - Enables or disables the date distortion effect
date_distortion = yes
Supported Scopes: all

refresh_portraits - Signals to portrait objects that they need to refresh some of their properties
	refresh_portraits = planet/room/character/all
Supported Scopes: country

start_astral_action_cooldown - Starts the cooldown of an astral action defined with uses_custom_cooldown = yes
start_astral_action_cooldown=<key>
Supported Scopes: country

perform_astral_action_unlock_check - Unlocks Astral Actions that have become unlockable since the last time this effect was called.
perform_astral_action_unlock_check = yes
Supported Scopes: country

activate_fog_machine - Creates cloud effect at every star system controlled by the country
activate_fog_machine = <cloud_type>
Supported Scopes: country

deactivate_fog_machine - Deactivates country fog machine
deactivate_fog_machine = yes
Supported Scopes: country

fog_machine_auto_tracking - Switches on/off galactic object ownership auto tracking for country fog machine
fog_machine_auto_tracking = yes/no
Supported Scopes: country

create_cosmic_storm - Creates a cosmic storm
storm_start_position = <target>
storm_end_position = <target>
storm_min_radius = <value>
storm_max_radius = <value>
storm_max_range = <value>
type = <string>
Supported Scopes: all

destroy_cosmic_storm - Destroy the scoped storm.
Supported Scopes: cosmic_storm

cosmic_storm_event - Fires a storm event for the scoped storm
storm_event = {
	id = <id>
	days = x (optional: specify delay)
	random = y (optional: specify random delay from 0 to value, which is added on to the 'days' delay)
	scopes = { from = fromfrom } (optional: specify scope overrides)
}
Supported Scopes: cosmic_storm

cosmic_storm_influence_field_event - Fires a storm event for the scoped storm influence field
storm_influence_event = {
	id = <id>
	days = x (optional: specify delay)
	random = y (optional: specify random delay from 0 to value, which is added on to the 'days' delay)
	scopes = { from = fromfrom } (optional: specify scope overrides)
}
Supported Scopes: cosmic_storm_influence_field

set_auto_upgrade_components - Sets wether or not the design automatically upgrades its components.
set_auto_upgrade_components = yes
Supported Scopes: design

spawn_random_storm - Spawn a random storm type with a random start and end position
Supported Scopes: all

create_cosmic_storm_influence_field - Creates a storm influence field in a certain radius
radius = <float>
Supported Scopes: planet starbase

destroy_cosmic_storm_influence_field - Destroys a storm influence field with center
 center = <target>
Supported Scopes: planet starbase

recalculate_storm_influence_field - Recalculates the influence for each system in an influence field
Supported Scopes: cosmic_storm_influence_field

set_fauna_fleet_growth_stance - Sets Space Fauna growth stance. Setting to 'none' resets stance to use default country policy.
set_fauna_fleet_growth_stance = <value> (controlled/excessive/none)
Supported Scopes: country fleet

start_storm_area_placing - Starts the storm placing mode with radius 
radius = <float> 
Supported Scopes: all

give_specimen - Gives a given specimen to the target country.
give_specimen = { key = <specimen> origin = <key> }
Supported Scopes: country

remove_specimen - Removes specified specimen from the target country.
remove_specimen = <specimen>
Supported Scopes: country

set_emergency_fund_active - Sets whether the emergency fund should be active or not.
Supported Scopes: all

storm_apply_aftermath_modifier - Applies Cosmic Storm Aftermath Modifiers. You can specify up to a max of 10 Severities and each one will be chosen based on it's chance.
storm_apply_aftermath_modifier = { severity = { modifier = <key>, days = <ModifierDuration> chance = <WeightedChance> effect  = <OnAppliedOptionalEffect> }}
Supported Scopes: all

set_cosmic_storm - Sets a storm on a system
 cosmic_storm = <target>
Supported Scopes: galactic_object

unset_cosmic_storm - Unsets a storm on a system
Supported Scopes: galactic_object

set_emergency_fund_contribution_rate - Sets rate for contributions to the emergency fund.
Supported Scopes: all

finish_council_agenda - Tries to finish the current council agenda for the scoped country
finish_council_agenda = yes/no
Supported Scopes: country

add_mission_counter - Increments (or decrements with negative values) a mission counter for the scoped country by a specific amount
add_mission_counter = { mission = <key> counter = <key> amount = <int>/<variable> }
Supported Scopes: country

set_storm_flag - Sets an arbitrarily-named flag on the scoped cosmic storm.
set_storm_flag = <key> (note: one can use e.g. my_flag@from to track relationships between objects)
Supported Scopes: cosmic_storm

set_mission_counter - Sets a mission counter for the scoped country to a specific amount
set_mission_counter = { mission = <key> counter = <key> amount = <int>/<variable> }
Supported Scopes: country

stop_mission - Stops the mission with the given status, triggering the relevant effects.
 stop_mission = { mission = <mission_key> status = success }
Supported Scopes: planet country ship pop pop group

give_culling_rewards - Gives associated culling rewards from a space fauna design to the target country.
give_culling_rewards = { design = <key> }
Supported Scopes: country

give_dna - Gives given space fauna DNA with given rarity to the target country.
give_dna = { ship_category = <key> rarity = <key> (optional) }
Supported Scopes: country

add_to_vivarium - Gives Space Fauna in the Vivarium using given ship design with given rarity to the target country.
add_to_vivarium = { design = <key> rarity = <key>/highest (optional) amount = <int> (optional) }
Supported Scopes: country

reanimate_space_fauna - Reanimates Space Fauna ship(s) back to life in zombie form.
reanimate_space_fauna = {
	fleet = <fleet>
}
Supported Scopes: ship debris

spawn_custom_debris - Spawns a custom debris project with the current fleet.
	for = <country> - country to give the debris project to.
	should_add_ship_to_debris = trigger (optional) - used to check if the ship must be added to the debris.
	must_scavenge/must_research = yes/no (default no) - used to specify and override country behaviour towards this debris.
	reset_killed_ship_designs = yes/no (default no) - used to force the fleet to reset its killed ships designs.
Supported Scopes: fleet

select_decision - Selects a decision on a planet
Supported Scopes: planet

return_leader_from_exile - Returns the leader from a custom name
return_leader_from_exile = <key>/<key@scope>
Supported Scopes: country

kill_exiled_leader - Kills the scoped leader saved with a custom name
kill_exiled_leader = <key>/<key@scope>
Supported Scopes: country

lock_storm_in_place - If yes, locks a Cosmic Storm in place. If no, it advances again at its normal speed.
Supported Scopes: cosmic_storm

set_ship_construction_type - Set scoped starbase's current construction type
set_ship_construction_type = <starbase_type/none>
Supported Scopes: starbase

link_to - Link the scoped megastructure bypass to the given target megastructure bypass.
set_linked_to = from
Supported Scopes: megastructure

steal_specimens - Steals random specimens from given country.
steal_specimens = { who = <country> category = <category_key>/all/any count = <int>show_nofication = <yes/no> }
Supported Scopes: country

release_vivarium_fauna - Releases into the wild space fauna contained in the scoped country's Vivarium, from all or given ship category.	Resulting fleet owner can be specified.	Space Fauna can be culled for resources instead by specifying 'cull_vivarium_critter = yes'.release_vivarium_fauna = { category = <ship_category>/all location = <target> owner = <country>cull_vivarium_critter = <yes/no> }
Supported Scopes: country

release_vivarium_fauna_count - Releases into the wild a specific amount of space fauna contained in the scoped country's Vivarium.Rarest fauna is released in priority.	Resulting fleet owners can be specified.	release_vivarium_fauna_count = { count = <capacity_to_release> location = <target> owners = { <category> = <country> } }
Supported Scopes: country

create_smaller_size_creature_in_fleet - Creates new creatures of the smaller ship size in the same fleet
create_smaller_size_creature_in_fleet = <value>
Supported Scopes: ship

integrate_species - Triggers the sub-species integration step for a country.
integrate_species = yes 
Supported Scopes: country

copy_traditions_from - Copies the traditions of the target country into the scoped country. Traditions are added to the existing traditions, and the potential/possible triggers are respected.the traditions listed in the exceptions list are not copied.
copy_traditions_from = {
    target = FROM
    exceptions = { tradition1 tradition2 }
}
Supported Scopes: country

copy_ascension_perks_from - Copies the Ascension Perks of the target country into the scoped country. Perks are added to the existing perks, and the potential/possible triggers are respected.the perkss listed in the exceptions list are not copied.
copy_ascension_perks_from = {
    target = FROM
    exceptions = { perk1 perk2 }
}
Supported Scopes: country

remove_tradition - Remove the target tradition from the scoped Country.
remove_tradition = tradition_key
Supported Scopes: planet country ship pop pop group

remove_tradition_tree - Remove the target tradition tree from the scoped Country.
remove_tradition_tree = tradition_category_key
Supported Scopes: planet country ship pop pop group

add_ascension_perk - Adds the specified ascension perk to the scoped country.
add_ascension_perk = ascension_perk_key
Supported Scopes: country

remove_ascension_perk - Remove the target ascension perk from the scoped Country.
remove_ascension_perk = ascension_perk_key
Supported Scopes: planet country ship pop pop group

add_focus_progress - Adds the defined amount of focus progress in the defined focus category
add_focus_progress = { category = <focus_category_key> amount = <float>/<variable> }
Supported Scopes: country

add_pop_amount - Adds the amount of pops to the scope pop group.
add_pop_amount = <num>
Supported Scopes: pop group

remove_pop_amount - Removes the amount of pops from the scope pop group.
remove_pop_amount = <num>
Supported Scopes: pop group

scale_pop_amount - Scales the amount of pops in the scope pop group
scale_pop_amount = <value>
Supported Scopes: pop group

transfer_pop_amount - Transfer the amount of pops from the source pop group to the target pop group
transfer_pop_amount = {
	source = <source pop group>
	target = <target pop group>
	amount = <amount (or percentage%)>
}
Supported Scopes: all

unlock_council_selection - Unlocks council selection
unlock_council_selection = yes
Supported Scopes: country

validate_planet_buildings_and_districts - Checks whether the planets and districts on the planet are valid (their potential triggers are fulfilled), removes or replaces them if not.
validate_planet_buildings_and_districts = yes
Supported Scopes: planet

add_deposit_category_effect - Adds random non-blocker resource deposit to the scoped planet of a certain category
add_deposit_category_effect = <category>
Supported Scopes: planet

stop_terraform_process - Stops terraforming process of scoped planet
Supported Scopes: planet

reset_event_chain_counter - Resets n event chain counter for the scoped country
reset_event_chain_counter = { event_chain = <key> counter = <key> }
Supported Scopes: country

add_council_agenda_progress - Instantly adds council agenda progress
add_council_agenda_progress = 5
Supported Scopes: country

add_council_agenda_progress_percent - Gives percentage progress (-1.0-1.0) in the current agenda to the scoped country
add_council_agenda_progress_percent = <float>/<variable>
Supported Scopes: country

unlock_council_slots - Unlocks council slots
unlock_council_slots = 1
Supported Scopes: country

set_council_agenda - Set the Country's council agenda 
set_council_agenda = agenda_lets_be_friends
Supported Scopes: country

country_event - Fires a country event for the scoped country, with optional DAYS and RANDOM delay
country_event = {
	id = <id>
	days = x (optional: specify delay)
	random = y (optional: specify random delay, capped at value)
	scopes = { from = fromfrom } (optional: specify scope overrides)
}
Supported Scopes: country

planet_event - Fires a planet event for the scoped planet, with optional DAYS and RANDOM delay
planet_event = {
	id = <id>
	days = x (optional: specify delay)
	random = y (optional: specify random delay, capped at value)
	scopes = { from = fromfrom } (optional: specify scope overrides)
}
Supported Scopes: planet

random - All enclosed effects may or may not be executed depending on set chance
random = { chance = 50 <effects> }
Supported Scopes: all

create_ship_design - Creates a new ship design for use with last_created_design target
create_ship_design = { design = <key> ftl = <target, optional, sets FTL drive to target country's> }
Supported Scopes: all

change_government - Change the scoped country's government authority and/or civics
change_government = random
or
change_government = {
	authority = random / <key>
	civics = random / { civic = <key> civic = random }
cooldown = no (default: yes)
remove_invalid_civics = yes (default: no)
}
Supported Scopes: country

ship_event - Fires a ship event for the scoped ship, with optional DAYS and RANDOM delay
ship_event = {
	id = <id>
	days = x (optional: specify delay)
	random = y (optional: specify random delay from 0 to value, which is added on to the 'days' delay)
	scopes = { from = fromfrom } (optional: specify scope overrides)
}
Supported Scopes: ship

pop_event - Fires a pop event for the scoped pop, with optional DAYS and RANDOM delay
pop_event = {
	id = <id>
	days = x (optional: specify delay)
	random = y (optional: specify random delay from 0 to value, which is added on to the 'days' delay)
	scopes = { from = fromfrom } (optional: specify scope overrides)
}
Supported Scopes: pop

pop_group_event - Fires a pop group event for the scoped pop group, with optional DAYS and RANDOM delay
pop_group_event = {
	id = <id>
	days = x (optional: specify delay)
	random = y (optional: specify random delay from 0 to value, which is added on to the 'days' delay)
	scopes = { from = fromfrom } (optional: specify scope overrides)
}
Supported Scopes: pop group

enable_special_project - Enables a specific special research project for target country at a specific location (should be same as the current scope where possible)
enable_special_project = { name = <project key> owner = <target, default = root> location = <target, ideally THIS (that is default)> }
Supported Scopes: all

add_resource - Adds specific resource to the stockpile for the country scope:
add_resource = {
	<resource_name_1> = <value_1>
	<resource_name_2> = <value_2>
	...
	mult = <variable> (optional: multiplies all gained resources by a variable)
}
Supported Scopes: country

fleet_event - Fires a fleet event for the scoped fleet, with optional DAYS and RANDOM delay
fleet_event = {
	id = <id>
	days = x (optional: specify delay)
	random = y (optional: specify random delay from 0 to value, which is added on to the 'days' delay)
	scopes = { from = fromfrom } (optional: specify scope overrides)
}
Supported Scopes: fleet

pop_remove_ethic - Removes a specific ethic from the scoped pop
pop_remove_ethic = <key>
Supported Scopes: pop

set_faction_extorted - Sets the scope faction as extorted and removes extortion from any other ones
set_faction_extorted = <yes|no>
Supported Scopes: pop_faction

create_rebels - Creates a rebellion
create_rebels = {
	name = <random / string>
	authority = <random / key>
	civics = random / { civic = <key> civic = random }
	species = <target>
	ethos = <random / { ethic = <key> ethic = <key> }
}
Supported Scopes: planet

cancel_terraformation - Cancels terraformation of the scoped planet
cancel_terraformation = yes
Supported Scopes: planet

while - Repeats enclosed effects while limit criteria are met or until set iteration count is reached
while = { limit = { <triggers> } <effects> }
 while = { count = [3|Variable] <effects> }
Supported Scopes: all

clear_blocker - Clears scoped deposit blocker and fires its on_cleared effect
clear_blocker = yes
Supported Scopes: deposit

remove_ship_design - Removes a specific ship design from the scoped country
remove_ship_design = <target/last_created_design>
Supported Scopes: country

remove_global_ship_design - Removes a specific global design from the game
remove_global_ship_design = <target>
Supported Scopes: all

every_system_in_cluster - Executes enclosed effects on every system in the cluster that meet the limit criteria
every_system_in_cluster = { limit = { <triggers> } <effects> }
Supported Scopes: all

create_cluster - Creates a cluster centered around the specified spatial object
create_cluster = {
	id = <some_id>
	center = <system, spatial object>
	radius = 30
}
Supported Scopes: all

remove_army - Removes the scoped army
remove_army = yes
Supported Scopes: army

prevent_anomaly - Disables or enables anomaly generation for the scoped planet
prevent_anomaly = yes
Supported Scopes: planet

add_deposit - Adds resource deposit to the scoped object (note: if you add a blocker, it will add a random deposit that can be blocked by that deposit)
add_deposit = <key/random/random_blocker/random_nonblocker>
Supported Scopes: planet astral_rift

clear_deposits - Removes all deposits from the scoped planet
clear_deposits = yes
Supported Scopes: planet

set_country_type - Changes the country type of the scoped country
set_country_type = <key>
Supported Scopes: country

set_age - Sets the age of the scoped leader
set_age = <int>
Supported Scopes: leader

add_age - Adds the age of the scoped leader
add_age = <int>
Supported Scopes: leader

conquer - Conquers the planet by setting its owner to target country and adding an unhappiness modifier
conquer = <target country>
Supported Scopes: planet

pop_faction_event - Fires a pop faction event for the scoped pop faction, with optional DAYS and RANDOM delay
pop_faction_event = {
	id = <id>
	days = x (optional: specify delay)
	random = y (optional: specify random delay from 0 to value, which is added on to the 'days' delay)
	scopes = { from = fromfrom } (optional: specify scope overrides)
}
Supported Scopes: pop_faction

set_pop_faction_flag - Sets an arbitrarily-named flag on the scoped pop group's faction/pop faction
set_pop_faction_flag = <key> (note: one can use e.g. my_flag@from to track relationships between objects)
Supported Scopes: pop pop group pop_faction

remove_pop_faction_flag - Removes a flag from the scoped pop group's faction/pop faction
remove_pop_faction_flag = <key> (note: one can use e.g. my_flag@from to track relationships between objects)
Supported Scopes: pop pop group pop_faction

set_timed_pop_faction_flag - Sets an arbitrarily-named flag on the scoped pop faction for a set duration
set_timed_pop_faction_flag = {
	flag = <key> (note: one can use <key>@scope e.g. my_flag@from to track relationships between objects)
	days = <int>
}
Supported Scopes: pop pop group pop_faction

add_tech_progress - Gives percentage progress (0.0-1.0) in a specific tech to the scoped country
add_tech_progress = { tech = <key> progress = <float>/<variable> }
Supported Scopes: country

set_ruler_title_male - Sets the scoped country's male ruler's title.
set_ruler_title_male = RULER_TITLE_MALE
Supported Scopes: country

set_ruler_title_female - Sets the scoped country's female ruler's title.
set_ruler_title_female = RULER_TITLE_FEMALE
Supported Scopes: country

set_council_position_title_male - Sets the scoped country's council position's male title.
set_council_position_title_male = { position_tag = COUNCIL_POSITION_TAG title = TITLE_MALE }
Supported Scopes: country

set_council_position_title_female - Sets the scoped country's council position's female title.
set_council_position_title_female = { position_tag = COUNCIL_POSITION_TAG title = TITLE_FEMALE }
Supported Scopes: country

repair_building - Repairs a single instance of a specific building on the scoped planet
repair_building = <key>
Supported Scopes: planet

abort_special_project - Aborts a specific special project for the country, removing it from the situation log
abort_special_project = { type = <project key> location = <target> }
Supported Scopes: country

observer_event - Fires an observer event for all observers.
Supported Scopes: all

set_custom_capital_location - Sets a custom spatial object as custom country capital location.
set_custom_capital_location = <target>
Supported Scopes: country

spawn_planet - Spawns a planet in a system.
Supported Scopes: galactic_object

spawn_megastructure - Spawns a mega structure in a system.
spawn_megastructure = {
	type = ring_world_ruined
	name = <string>
	owner = <target>
	planet = <planet/star target>
	coords_from = <target> (use this or 'planet' to set the location)
	graphical_culture = <target>
	orbit_distance = 50
	orbit_angle = 50
}
Supported Scopes: galactic_object

remove_megastructure - Removes a mega structure.
remove_megastructure = <target mega structure>
Supported Scopes: all

trigger_megastructure_icon - if a planet has trigger_megastructure_icon = yes then the map icon for the star will show a megastructure icon
Supported Scopes: planet

run_ai_strategic_data - Recomputes ALL strategic data for AI = yes
Supported Scopes: country

get_trade_data - Passes special trade offer data from the target enclave country to the scoped country.
Only works inside certain parts of the script marked as ai_trade_facility.
get_trade_data = { target = <target> }
Supported Scopes: country

make_special_trade - Makes special trade deal between the target enclave country and the scoped country.
Only works inside certain parts of the script marked as ai_trade_facility.
make_special_trade = { target = <target> }
Supported Scopes: country

add_static_war_exhaustion - Adds static war exhaustion, scaled with value_for_planet_destruction, to owner of the battle location 
add_static_war_exhaustion = {
	attacker = <country>
	location = <planet> 
	value_for_planet_destruction = <0.0-1.0>/<variable> #scales the amount of war exhaustion that is added
}
Supported Scopes: country

set_planet_size - Sets the planet size to a specified number
set_planet_size = <int>
Supported Scopes: planet

add_skill_without_trait_selection - Adds to the scoped leader's skill level but does not select any traits
add_skill_without_trait_selection = 2
Supported Scopes: leader

run_ai_strategic_war_data - Recomputes strategic war ( attack / defense ) data for AI = yes
Supported Scopes: country

expire_site_event - Manually flags an archaeological event as expired
expire_site_event = ancrel.7003
Supported Scopes: archaeological_site

pass_resolution - Immediately passes the first found (oldest) proposed/voting for/failed resolution OR a new resolution of this type.
pass_resolution = <resolution type>
Supported Scopes: country

pass_resolution_no_cooldown - Immediately passes the first found (oldest) proposed/voting for/failed resolution OR a new resolution of this type. Skips the cooldown on the relevant category.
pass_resolution_no_cooldown = <resolution type>
Supported Scopes: country

first_contact_event - Fires a first contact event for the scoped first contact site, with optional DAYS and RANDOM delay
first_contact_event = {
	id = <id>
	days = x (optional: specify delay)
	random = y (optional: specify random delay from 0 to value, which is added on to the 'days' delay)
	scopes = { from = fromfrom } (optional: specify scope overrides)
}
Supported Scopes: first_contact

finish_first_contact - Ends the First Contact
finish_first_contact = yes
Supported Scopes: first_contact

set_galactic_custodian - Sets whether or not the scoped country is the Galactic Custodian
set_galactic_custodian = yes/no
Supported Scopes: country

set_galactic_emperor - Sets whether or not the scoped country is the Galactic Emperor
set_galactic_emperor = yes/no
Supported Scopes: country

add_imperial_authority - Add imperial_authority
add_imperial_authority = <value>
Supported Scopes: all

add_stage_modifier - Adds a specific modifier to the target's current stage for a set duration or until stage is changed
add_stage_modifier = { modifier = <key> days = <int>, -1 means it never expires> }
Supported Scopes: espionage_operation astral_rift

remove_stage_modifier - Removes a specific modifier from the target current stage
remove_stage_modifier = <key>
Supported Scopes: espionage_operation astral_rift

add_intel_report - Adds the intel level for the category selected. Default duration (0) is forever.
add_intel_report = { category = <string> level = <int> days = <int> who = <target> }
Supported Scopes: country

set_galactic_defense_force - Sets whether the Galactic Defense force or Imperial Armada exists
set_galactic_defense_force = yes/no
Supported Scopes: all

clear_intel_report - Removes all the intel reports related to the provided category.
clear_intel_report = { category = <string> who = <target> }
Supported Scopes: country

starbase_event - Fires a starbase event for the scoped starbase
starbase_event = {
	id = <id>
	days = x (optional: specify delay)
	random = y (optional: specify random delay from 0 to value, which is added on to the 'days' delay)
	scopes = { from = fromfrom } (optional: specify scope overrides)
}
Supported Scopes: starbase

system_event - Fires a system event for the scoped system
system_event = {
	id = <id>
	days = x (optional: specify delay)
	random = y (optional: specify random delay from 0 to value, which is added on to the 'days' delay)
	scopes = { from = fromfrom } (optional: specify scope overrides)
}
Supported Scopes: galactic_object

leader_event - Fires a leader event for the scoped leader
leader_event = {
	id = <id>
	days = x (optional: specify delay)
	random = y (optional: specify random delay from 0 to value, which is added on to the 'days' delay)
	scopes = { from = fromfrom } (optional: specify scope overrides)
}
Supported Scopes: leader

situation_event - Fires a situation event for the scoped situation
situation_event = {
	id = <id>
	days = x (optional: specify delay)
	random = y (optional: specify random delay from 0 to value, which is added on to the 'days' delay)
	scopes = { from = fromfrom } (optional: specify scope overrides)
}
Supported Scopes: situation

agreement_event - Fires an agreement event for the scoped agreement
agreement_event = {
	id = <id>
	days = x (optional: specify delay)
	random = y (optional: specify random delay from 0 to value, which is added on to the 'days' delay)
	scopes = { from = fromfrom } (optional: specify scope overrides)
}
Supported Scopes: agreement

transfer_galactic_defense_force_fleets - Moves all owned GDF fleets to the target.
transfer_galactic_defense_force_fleets = <target>
Supported Scopes: country

cancel_resolution - Immediately cancels/removes the latest active/passed/proposed/voting for/failed resolution of this type
cancel_resolution = <resolution type>
Supported Scopes: country

add_spy_network_level - Adds levels to the current Spy Network
add_spy_network_level = <int>
Supported Scopes: spy_network

join_alliance - Join federation with target
join_alliance = { who = <target> override_requirements = yes/no }
Supported Scopes: country

complete_tutorial_step - Create and sends an telemetry event keeping track of the tutorial steps for the current game
Supported Scopes: all

set_emperor_can_change_council_members - Sets whether the Galactic Emperor can change Imperial Council members or not
set_emperor_can_change_council_members = yes/no
Supported Scopes: all

give_fleet - Leases fleet out to the new controller country for a numbed of days 
give_fleet = {
	controller = <target country> 
	days = <number of days>
}
Supported Scopes: fleet

prolong_fleet_contract - Prolongs fleet's lease contract for a numbed of days 
prolong_fleet_contract = { days = <number of days> }
Supported Scopes: fleet

set_fleet_settings - Set fleet's settings, any unspecified setting will set to default value.
set_fleet_settings = { can_upgrade = no can_change_leader = no ... }
Supported Scopes: fleet

astral_rift_event - Fires an astral rift event with optional DAYS and RANDOM 
delay
astral_rift_event = {
	id = <id>
	days = x (optional: specify delay)
	random = y (optional: specify random delay from 0 to value, which is added on to the 'days' delay)
	scopes = { from = fromfrom } (optional: specify scope overrides)
}
Supported Scopes: astral_rift

fill_astral_rift_event_pool - Fills the astral rift event pool for every playable country.
Supported Scopes: country

bypass_event - Fires a bypass event for the scoped bypass, with optional DAYS and RANDOM delay
bypass_event = {
	id = <id>
	days = x (optional: specify delay)
	random = y (optional: specify random delay, capped at value)
	scopes = { from = fromfrom } (optional: specify scope overrides)
}
Supported Scopes: bypass

finish_astral_rift - Ends the Astral Rift exploration
finish_astral_rift = yes
Supported Scopes: astral_rift

set_next_astral_rift_event - Sets next Astral Rift event through an astral rift event ID, and another astral rift event ID to be called in case of a roll failed, alongside a trigger probability.	To fire an Astral Rift event immediately, use astral_rift_event instead.
set_next_astral_rift_event = {
	id = <event_id>
	on_roll_failed = <event_id> (optional: specify astral rift event set when a roll fails)
	fail_probability = <float> (optional: specify astral rift event probability to trigger on a failed roll)
}
Supported Scopes: astral_rift

unlock_exhibit - Unlocks an exhibit for given category from the target country.
unlock_exhibit = <category>
Supported Scopes: country

enable_mission - Enables a mission for target country
 enable_mission = { name = <mission key> }
Supported Scopes: all

refresh_leader_pool - Refreshes the scoped country's leader pool.
refresh_leader_pool = yes
Supported Scopes: country

add_resource_from_debris - Adds specific resource to the stockpile for the country scope and creates a debris notification:
add_resource = {
	<resource_name_1> = <value_1>
	<resource_name_2> = <value_2>
	...
	system = <system>
	mult = <variable> (optional: multiplies all gained resources by a variable)
}
Supported Scopes: country

add_timeline_event - Adds a new timeline event for the scope country.
add_timeline_event = {
  type = timeline_event_planet
  date = 2300.1.1 (optional - if not present, current date is used)
  targets = { ... } (optional - array of event targets. This depends on localization and what event targets the type requires)

  (There is also overrides that can be used to override settings on the database entries. The Id is required, and the others are optional)
  override_id = my_defined_unique_id
  override_text = { "button:MY_OTHER_LOC_STRING" "button2:ANOTHER_LOC_OVERRIDE" }  override_texture = { "button:GFX_short_button button2:GFX_otherbutton" }  override_tooltip, "loc_tooltip"  override_tooltip_delayed, "loc_delayed_tooltip"}
Supported Scopes: country

weighted_random_owned_pop_group - Weighted random on owned popgroups based on the popgroup size. Supports the same scopes as the owned_pop_group script list
Supported Scopes: planet country pop_faction sector

create_leader - Creates a new leader for the scoped country
create_leader = {
	name = random / <string>
	species = last_created / <target>
	class = random_ruler / <key>
	skill = <int> # The leader skill level, minimum LEADER_SKILL_MIN and maximum LEADER_MAX_SKILL_CAP.
	set_age = <int>
	traits = { <level> = <key> <level> = <key> } # The traits of the leader, i.e. "1 = leader_trait_bureaucrat".

	gender = <gender> # Optional, default = random.
	event_leader = yes / no # Optional, default = no. Sets if this is a event leader or not. Is checked through is_event_leader.
	immortal = yes / no # Optional, default = no.
	hide_age = yes / no # Optional, default = no.
	sub_type = <key> # Optional. Used for scientist subtypes.
	can_manually_change_location = yes / no # Optional, default = yes.
	can_assign_to_council = yes/no # Optional, default = yes.
	hide_leader = yes / no # Optional, default = no. Hides the leader from the player's list of leaders, and doesn't count them towards the leader cap.
	randomize_traits = yes / no # Optional, default = yes.
	leader_age_min = <int> # Optional, but requires leader_age_max if used. Used to randomize leader age within the age span between this and leader_age_max.
	leader_age_max = <int> # Optional, but requires leader_age_min if used. Used to randomize leader age within the age span between this and leader_age_min.
	use_regnal_name = yes/no # Optional, default = no. If generating a random name, use regnal names if the name list has them.	effect = { <effect> } # Optional. Scripted effect(s) that are run on the leader after it has been created.

	custom_description = <key> # Optional.
	custom_catch_phrase = <string> # Optional.
	skip_background_generation = yes / no # Optional, default = no. Disables random generation of a background.
	background_planet = <target> # Optional. Used as the home planet of the leader.
	background_job = <key> # Optional.
	background_ethic = <key> # Optional.
}
Supported Scopes: country

set_disabled - Enables or disables the scoped ship
set_disabled = no
Supported Scopes: ship

else - Executes enclosed effects if limit criteria of preceding 'if' or 'else_if' is not met
if = { limit = { <triggers> } <effects> }
else = { <effects> }
Supported Scopes: all

log - Prints a message to game.log for debugging purposes.
Supported Scopes: all

debug_break - Trigger an assertion to stop the debugger when encountering this effect; argument is ignored
debug_break = yes
Supported Scopes: all

inverted_switch - Executes the first appropriate effect set for a specific trigger treated as NOT.
inverted_switch = {
	trigger = <trigger>
	<corresponding key/bool/int> = { <effect> }
	<corresponding key/bool/int> > (less/greater than appear 'reversed') { <effect> }
	default = { <effect> }
}
Supported Scopes: all

random_agreement - Iterate through each agreement - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
random_agreement = {
	limit = { <triggers> }
	weights = { (optional - adds weights to affect the chance a specific object is selected)
		base = float
		modifier = { <add/factor = float> <triggers> }
	}
	<effects>
}
Supported Scopes: country no_scope

ordered_agreement - Iterate through each agreement - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
ordered_agreement = {
	limit = { <triggers> }
	position = <integer, starting with 0>
	order_by = <variable>/trigger:<trigger>
	inverse = yes/no (default: no - if yes, then 0 is lowest rather than highest)
	<effects>
}
Supported Scopes: country no_scope

every_agreement - Iterate through each agreement - executes the enclosed effects on all of them for which the limit triggers return true
every_agreement = { limit = { <triggers> } <effects> }
Supported Scopes: country no_scope

random_ambient_object - Iterate through every ambient object in the game - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
random_ambient_object = {
	limit = { <triggers> }
	weights = { (optional - adds weights to affect the chance a specific object is selected)
		base = float
		modifier = { <add/factor = float> <triggers> }
	}
	<effects>
}
Supported Scopes: all

ordered_ambient_object - Iterate through every ambient object in the game - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
ordered_ambient_object = {
	limit = { <triggers> }
	position = <integer, starting with 0>
	order_by = <variable>/trigger:<trigger>
	inverse = yes/no (default: no - if yes, then 0 is lowest rather than highest)
	<effects>
}
Supported Scopes: all

every_ambient_object - Iterate through every ambient object in the game - executes the enclosed effects on all of them for which the limit triggers return true
every_ambient_object = { limit = { <triggers> } <effects> }
Supported Scopes: all

random_system_ambient_object - Iterate through every ambient object in the solar system - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
random_system_ambient_object = {
	limit = { <triggers> }
	weights = { (optional - adds weights to affect the chance a specific object is selected)
		base = float
		modifier = { <add/factor = float> <triggers> }
	}
	<effects>
}
Supported Scopes: galactic_object

ordered_system_ambient_object - Iterate through every ambient object in the solar system - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
ordered_system_ambient_object = {
	limit = { <triggers> }
	position = <integer, starting with 0>
	order_by = <variable>/trigger:<trigger>
	inverse = yes/no (default: no - if yes, then 0 is lowest rather than highest)
	<effects>
}
Supported Scopes: galactic_object

every_system_ambient_object - Iterate through every ambient object in the solar system - executes the enclosed effects on all of them for which the limit triggers return true
every_system_ambient_object = { limit = { <triggers> } <effects> }
Supported Scopes: galactic_object

random_archaeological_site - Iterate through every archaeological sites - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
random_archaeological_site = {
	limit = { <triggers> }
	weights = { (optional - adds weights to affect the chance a specific object is selected)
		base = float
		modifier = { <add/factor = float> <triggers> }
	}
	<effects>
}
Supported Scopes: all

ordered_archaeological_site - Iterate through every archaeological sites - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
ordered_archaeological_site = {
	limit = { <triggers> }
	position = <integer, starting with 0>
	order_by = <variable>/trigger:<trigger>
	inverse = yes/no (default: no - if yes, then 0 is lowest rather than highest)
	<effects>
}
Supported Scopes: all

every_archaeological_site - Iterate through every archaeological sites - executes the enclosed effects on all of them for which the limit triggers return true
every_archaeological_site = { limit = { <triggers> } <effects> }
Supported Scopes: all

random_owned_army - Iterate through each army that is owned by the country - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
random_owned_army = {
	limit = { <triggers> }
	weights = { (optional - adds weights to affect the chance a specific object is selected)
		base = float
		modifier = { <add/factor = float> <triggers> }
	}
	<effects>
}
Supported Scopes: country

ordered_owned_army - Iterate through each army that is owned by the country - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
ordered_owned_army = {
	limit = { <triggers> }
	position = <integer, starting with 0>
	order_by = <variable>/trigger:<trigger>
	inverse = yes/no (default: no - if yes, then 0 is lowest rather than highest)
	<effects>
}
Supported Scopes: country

every_owned_army - Iterate through each army that is owned by the country - executes the enclosed effects on all of them for which the limit triggers return true
every_owned_army = { limit = { <triggers> } <effects> }
Supported Scopes: country

random_planet_army - Iterate through each army on the planet (not in ground combat), regardless of owner. - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
random_planet_army = {
	limit = { <triggers> }
	weights = { (optional - adds weights to affect the chance a specific object is selected)
		base = float
		modifier = { <add/factor = float> <triggers> }
	}
	<effects>
}
Supported Scopes: planet

ordered_planet_army - Iterate through each army on the planet (not in ground combat), regardless of owner. - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
ordered_planet_army = {
	limit = { <triggers> }
	position = <integer, starting with 0>
	order_by = <variable>/trigger:<trigger>
	inverse = yes/no (default: no - if yes, then 0 is lowest rather than highest)
	<effects>
}
Supported Scopes: planet

every_planet_army - Iterate through each army on the planet (not in ground combat), regardless of owner. - executes the enclosed effects on all of them for which the limit triggers return true
every_planet_army = { limit = { <triggers> } <effects> }
Supported Scopes: planet

random_ground_combat_defender - Iterate through each army currently defending the planet in ground combat - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
random_ground_combat_defender = {
	limit = { <triggers> }
	weights = { (optional - adds weights to affect the chance a specific object is selected)
		base = float
		modifier = { <add/factor = float> <triggers> }
	}
	<effects>
}
Supported Scopes: planet

ordered_ground_combat_defender - Iterate through each army currently defending the planet in ground combat - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
ordered_ground_combat_defender = {
	limit = { <triggers> }
	position = <integer, starting with 0>
	order_by = <variable>/trigger:<trigger>
	inverse = yes/no (default: no - if yes, then 0 is lowest rather than highest)
	<effects>
}
Supported Scopes: planet

every_ground_combat_defender - Iterate through each army currently defending the planet in ground combat - executes the enclosed effects on all of them for which the limit triggers return true
every_ground_combat_defender = { limit = { <triggers> } <effects> }
Supported Scopes: planet

random_ground_combat_attacker - Iterate through each army currently attacking the planet in ground combat - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
random_ground_combat_attacker = {
	limit = { <triggers> }
	weights = { (optional - adds weights to affect the chance a specific object is selected)
		base = float
		modifier = { <add/factor = float> <triggers> }
	}
	<effects>
}
Supported Scopes: planet

ordered_ground_combat_attacker - Iterate through each army currently attacking the planet in ground combat - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
ordered_ground_combat_attacker = {
	limit = { <triggers> }
	position = <integer, starting with 0>
	order_by = <variable>/trigger:<trigger>
	inverse = yes/no (default: no - if yes, then 0 is lowest rather than highest)
	<effects>
}
Supported Scopes: planet

every_ground_combat_attacker - Iterate through each army currently attacking the planet in ground combat - executes the enclosed effects on all of them for which the limit triggers return true
every_ground_combat_attacker = { limit = { <triggers> } <effects> }
Supported Scopes: planet

random_astral_rift - Iterate through every astral rift - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
random_astral_rift = {
	limit = { <triggers> }
	weights = { (optional - adds weights to affect the chance a specific object is selected)
		base = float
		modifier = { <add/factor = float> <triggers> }
	}
	<effects>
}
Supported Scopes: all

ordered_astral_rift - Iterate through every astral rift - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
ordered_astral_rift = {
	limit = { <triggers> }
	position = <integer, starting with 0>
	order_by = <variable>/trigger:<trigger>
	inverse = yes/no (default: no - if yes, then 0 is lowest rather than highest)
	<effects>
}
Supported Scopes: all

every_astral_rift - Iterate through every astral rift - executes the enclosed effects on all of them for which the limit triggers return true
every_astral_rift = { limit = { <triggers> } <effects> }
Supported Scopes: all

random_bypass - Iterate through every bypass - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
random_bypass = {
	limit = { <triggers> }
	weights = { (optional - adds weights to affect the chance a specific object is selected)
		base = float
		modifier = { <add/factor = float> <triggers> }
	}
	<effects>
}
Supported Scopes: all

ordered_bypass - Iterate through every bypass - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
ordered_bypass = {
	limit = { <triggers> }
	position = <integer, starting with 0>
	order_by = <variable>/trigger:<trigger>
	inverse = yes/no (default: no - if yes, then 0 is lowest rather than highest)
	<effects>
}
Supported Scopes: all

every_bypass - Iterate through every bypass - executes the enclosed effects on all of them for which the limit triggers return true
every_bypass = { limit = { <triggers> } <effects> }
Supported Scopes: all

random_cosmic_storm - Iterate through all cosmic storms in the galaxy - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
random_cosmic_storm = {
	limit = { <triggers> }
	weights = { (optional - adds weights to affect the chance a specific object is selected)
		base = float
		modifier = { <add/factor = float> <triggers> }
	}
	<effects>
}
Supported Scopes: all

ordered_cosmic_storm - Iterate through all cosmic storms in the galaxy - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
ordered_cosmic_storm = {
	limit = { <triggers> }
	position = <integer, starting with 0>
	order_by = <variable>/trigger:<trigger>
	inverse = yes/no (default: no - if yes, then 0 is lowest rather than highest)
	<effects>
}
Supported Scopes: all

every_cosmic_storm - Iterate through all cosmic storms in the galaxy - executes the enclosed effects on all of them for which the limit triggers return true
every_cosmic_storm = { limit = { <triggers> } <effects> }
Supported Scopes: all

random_system_within_storm - Iterate through all systems within the storm - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
random_system_within_storm = {
	limit = { <triggers> }
	weights = { (optional - adds weights to affect the chance a specific object is selected)
		base = float
		modifier = { <add/factor = float> <triggers> }
	}
	<effects>
}
Supported Scopes: cosmic_storm

ordered_system_within_storm - Iterate through all systems within the storm - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
ordered_system_within_storm = {
	limit = { <triggers> }
	position = <integer, starting with 0>
	order_by = <variable>/trigger:<trigger>
	inverse = yes/no (default: no - if yes, then 0 is lowest rather than highest)
	<effects>
}
Supported Scopes: cosmic_storm

every_system_within_storm - Iterate through all systems within the storm - executes the enclosed effects on all of them for which the limit triggers return true
every_system_within_storm = { limit = { <triggers> } <effects> }
Supported Scopes: cosmic_storm

random_cosmic_storm_start_position - Iterate through all systems valid to be a storms start position - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
random_cosmic_storm_start_position = {
	limit = { <triggers> }
	weights = { (optional - adds weights to affect the chance a specific object is selected)
		base = float
		modifier = { <add/factor = float> <triggers> }
	}
	<effects>
}
Supported Scopes: all

ordered_cosmic_storm_start_position - Iterate through all systems valid to be a storms start position - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
ordered_cosmic_storm_start_position = {
	limit = { <triggers> }
	position = <integer, starting with 0>
	order_by = <variable>/trigger:<trigger>
	inverse = yes/no (default: no - if yes, then 0 is lowest rather than highest)
	<effects>
}
Supported Scopes: all

every_cosmic_storm_start_position - Iterate through all systems valid to be a storms start position - executes the enclosed effects on all of them for which the limit triggers return true
every_cosmic_storm_start_position = { limit = { <triggers> } <effects> }
Supported Scopes: all

random_cosmic_storm_end_position - Iterate through all systems valid to be a storms end position - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
random_cosmic_storm_end_position = {
	limit = { <triggers> }
	weights = { (optional - adds weights to affect the chance a specific object is selected)
		base = float
		modifier = { <add/factor = float> <triggers> }
	}
	<effects>
}
Supported Scopes: all

ordered_cosmic_storm_end_position - Iterate through all systems valid to be a storms end position - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
ordered_cosmic_storm_end_position = {
	limit = { <triggers> }
	position = <integer, starting with 0>
	order_by = <variable>/trigger:<trigger>
	inverse = yes/no (default: no - if yes, then 0 is lowest rather than highest)
	<effects>
}
Supported Scopes: all

every_cosmic_storm_end_position - Iterate through all systems valid to be a storms end position - executes the enclosed effects on all of them for which the limit triggers return true
every_cosmic_storm_end_position = { limit = { <triggers> } <effects> }
Supported Scopes: all

random_system_added_to_storm - Iterate through all systems added to the storm - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
random_system_added_to_storm = {
	limit = { <triggers> }
	weights = { (optional - adds weights to affect the chance a specific object is selected)
		base = float
		modifier = { <add/factor = float> <triggers> }
	}
	<effects>
}
Supported Scopes: cosmic_storm

ordered_system_added_to_storm - Iterate through all systems added to the storm - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
ordered_system_added_to_storm = {
	limit = { <triggers> }
	position = <integer, starting with 0>
	order_by = <variable>/trigger:<trigger>
	inverse = yes/no (default: no - if yes, then 0 is lowest rather than highest)
	<effects>
}
Supported Scopes: cosmic_storm

every_system_added_to_storm - Iterate through all systems added to the storm - executes the enclosed effects on all of them for which the limit triggers return true
every_system_added_to_storm = { limit = { <triggers> } <effects> }
Supported Scopes: cosmic_storm

random_system_removed_from_storm - Iterate through all systems removed from storm - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
random_system_removed_from_storm = {
	limit = { <triggers> }
	weights = { (optional - adds weights to affect the chance a specific object is selected)
		base = float
		modifier = { <add/factor = float> <triggers> }
	}
	<effects>
}
Supported Scopes: cosmic_storm

ordered_system_removed_from_storm - Iterate through all systems removed from storm - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
ordered_system_removed_from_storm = {
	limit = { <triggers> }
	position = <integer, starting with 0>
	order_by = <variable>/trigger:<trigger>
	inverse = yes/no (default: no - if yes, then 0 is lowest rather than highest)
	<effects>
}
Supported Scopes: cosmic_storm

every_system_removed_from_storm - Iterate through all systems removed from storm - executes the enclosed effects on all of them for which the limit triggers return true
every_system_removed_from_storm = { limit = { <triggers> } <effects> }
Supported Scopes: cosmic_storm

random_owned_storm_influence_field - Iterate through all influence fields owned by a country - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
random_owned_storm_influence_field = {
	limit = { <triggers> }
	weights = { (optional - adds weights to affect the chance a specific object is selected)
		base = float
		modifier = { <add/factor = float> <triggers> }
	}
	<effects>
}
Supported Scopes: country

ordered_owned_storm_influence_field - Iterate through all influence fields owned by a country - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
ordered_owned_storm_influence_field = {
	limit = { <triggers> }
	position = <integer, starting with 0>
	order_by = <variable>/trigger:<trigger>
	inverse = yes/no (default: no - if yes, then 0 is lowest rather than highest)
	<effects>
}
Supported Scopes: country

every_owned_storm_influence_field - Iterate through all influence fields owned by a country - executes the enclosed effects on all of them for which the limit triggers return true
every_owned_storm_influence_field = { limit = { <triggers> } <effects> }
Supported Scopes: country

random_system_in_cosmic_storm_influence_field - Iterate through all influence fields owned by a country - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
random_system_in_cosmic_storm_influence_field = {
	limit = { <triggers> }
	weights = { (optional - adds weights to affect the chance a specific object is selected)
		base = float
		modifier = { <add/factor = float> <triggers> }
	}
	<effects>
}
Supported Scopes: cosmic_storm_influence_field

ordered_system_in_cosmic_storm_influence_field - Iterate through all influence fields owned by a country - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
ordered_system_in_cosmic_storm_influence_field = {
	limit = { <triggers> }
	position = <integer, starting with 0>
	order_by = <variable>/trigger:<trigger>
	inverse = yes/no (default: no - if yes, then 0 is lowest rather than highest)
	<effects>
}
Supported Scopes: cosmic_storm_influence_field

every_system_in_cosmic_storm_influence_field - Iterate through all influence fields owned by a country - executes the enclosed effects on all of them for which the limit triggers return true
every_system_in_cosmic_storm_influence_field = { limit = { <triggers> } <effects> }
Supported Scopes: cosmic_storm_influence_field

random_country - Iterate through all countries - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
random_country = {
	limit = { <triggers> }
	weights = { (optional - adds weights to affect the chance a specific object is selected)
		base = float
		modifier = { <add/factor = float> <triggers> }
	}
	<effects>
}
Supported Scopes: all

ordered_country - Iterate through all countries - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
ordered_country = {
	limit = { <triggers> }
	position = <integer, starting with 0>
	order_by = <variable>/trigger:<trigger>
	inverse = yes/no (default: no - if yes, then 0 is lowest rather than highest)
	<effects>
}
Supported Scopes: all

every_country - Iterate through all countries - executes the enclosed effects on all of them for which the limit triggers return true
every_country = { limit = { <triggers> } <effects> }
Supported Scopes: all

random_relation - Iterate through all relations - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
random_relation = {
	limit = { <triggers> }
	weights = { (optional - adds weights to affect the chance a specific object is selected)
		base = float
		modifier = { <add/factor = float> <triggers> }
	}
	<effects>
}
Supported Scopes: country

ordered_relation - Iterate through all relations - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
ordered_relation = {
	limit = { <triggers> }
	position = <integer, starting with 0>
	order_by = <variable>/trigger:<trigger>
	inverse = yes/no (default: no - if yes, then 0 is lowest rather than highest)
	<effects>
}
Supported Scopes: country

every_relation - Iterate through all relations - executes the enclosed effects on all of them for which the limit triggers return true
every_relation = { limit = { <triggers> } <effects> }
Supported Scopes: country

random_neighbor_country - Iterate through all neighbor countries - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
random_neighbor_country = {
	limit = { <triggers> }
	weights = { (optional - adds weights to affect the chance a specific object is selected)
		base = float
		modifier = { <add/factor = float> <triggers> }
	}
	<effects>
}
Supported Scopes: country

ordered_neighbor_country - Iterate through all neighbor countries - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
ordered_neighbor_country = {
	limit = { <triggers> }
	position = <integer, starting with 0>
	order_by = <variable>/trigger:<trigger>
	inverse = yes/no (default: no - if yes, then 0 is lowest rather than highest)
	<effects>
}
Supported Scopes: country

every_neighbor_country - Iterate through all neighbor countries - executes the enclosed effects on all of them for which the limit triggers return true
every_neighbor_country = { limit = { <triggers> } <effects> }
Supported Scopes: country

random_country_neighbor_to_system - Iterate through all countries that own system 1 jump away from current system (bypasses included) - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
random_country_neighbor_to_system = {
	limit = { <triggers> }
	weights = { (optional - adds weights to affect the chance a specific object is selected)
		base = float
		modifier = { <add/factor = float> <triggers> }
	}
	<effects>
}
Supported Scopes: galactic_object

ordered_country_neighbor_to_system - Iterate through all countries that own system 1 jump away from current system (bypasses included) - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
ordered_country_neighbor_to_system = {
	limit = { <triggers> }
	position = <integer, starting with 0>
	order_by = <variable>/trigger:<trigger>
	inverse = yes/no (default: no - if yes, then 0 is lowest rather than highest)
	<effects>
}
Supported Scopes: galactic_object

every_country_neighbor_to_system - Iterate through all countries that own system 1 jump away from current system (bypasses included) - executes the enclosed effects on all of them for which the limit triggers return true
every_country_neighbor_to_system = { limit = { <triggers> } <effects> }
Supported Scopes: galactic_object

random_rival_country - Iterate through all countries rivalled by the scoped country - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
random_rival_country = {
	limit = { <triggers> }
	weights = { (optional - adds weights to affect the chance a specific object is selected)
		base = float
		modifier = { <add/factor = float> <triggers> }
	}
	<effects>
}
Supported Scopes: country

ordered_rival_country - Iterate through all countries rivalled by the scoped country - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
ordered_rival_country = {
	limit = { <triggers> }
	position = <integer, starting with 0>
	order_by = <variable>/trigger:<trigger>
	inverse = yes/no (default: no - if yes, then 0 is lowest rather than highest)
	<effects>
}
Supported Scopes: country

every_rival_country - Iterate through all countries rivalled by the scoped country - executes the enclosed effects on all of them for which the limit triggers return true
every_rival_country = { limit = { <triggers> } <effects> }
Supported Scopes: country

random_federation_ally - Iterate through all countries in a federation with the scoped country - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
random_federation_ally = {
	limit = { <triggers> }
	weights = { (optional - adds weights to affect the chance a specific object is selected)
		base = float
		modifier = { <add/factor = float> <triggers> }
	}
	<effects>
}
Supported Scopes: country

ordered_federation_ally - Iterate through all countries in a federation with the scoped country - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
ordered_federation_ally = {
	limit = { <triggers> }
	position = <integer, starting with 0>
	order_by = <variable>/trigger:<trigger>
	inverse = yes/no (default: no - if yes, then 0 is lowest rather than highest)
	<effects>
}
Supported Scopes: country

every_federation_ally - Iterate through all countries in a federation with the scoped country - executes the enclosed effects on all of them for which the limit triggers return true
every_federation_ally = { limit = { <triggers> } <effects> }
Supported Scopes: country

random_playable_country - Iterate through all playable countries - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
random_playable_country = {
	limit = { <triggers> }
	weights = { (optional - adds weights to affect the chance a specific object is selected)
		base = float
		modifier = { <add/factor = float> <triggers> }
	}
	<effects>
}
Supported Scopes: all

ordered_playable_country - Iterate through all playable countries - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
ordered_playable_country = {
	limit = { <triggers> }
	position = <integer, starting with 0>
	order_by = <variable>/trigger:<trigger>
	inverse = yes/no (default: no - if yes, then 0 is lowest rather than highest)
	<effects>
}
Supported Scopes: all

every_playable_country - Iterate through all playable countries - executes the enclosed effects on all of them for which the limit triggers return true
every_playable_country = { limit = { <triggers> } <effects> }
Supported Scopes: all

random_subject - Iterate through all subjects of the scoped country - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
random_subject = {
	limit = { <triggers> }
	weights = { (optional - adds weights to affect the chance a specific object is selected)
		base = float
		modifier = { <add/factor = float> <triggers> }
	}
	<effects>
}
Supported Scopes: country

ordered_subject - Iterate through all subjects of the scoped country - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
ordered_subject = {
	limit = { <triggers> }
	position = <integer, starting with 0>
	order_by = <variable>/trigger:<trigger>
	inverse = yes/no (default: no - if yes, then 0 is lowest rather than highest)
	<effects>
}
Supported Scopes: country

every_subject - Iterate through all subjects of the scoped country - executes the enclosed effects on all of them for which the limit triggers return true
every_subject = { limit = { <triggers> } <effects> }
Supported Scopes: country

random_available_debris - Iterate through all debris belong to available special projects of the scoped country - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
random_available_debris = {
	limit = { <triggers> }
	weights = { (optional - adds weights to affect the chance a specific object is selected)
		base = float
		modifier = { <add/factor = float> <triggers> }
	}
	<effects>
}
Supported Scopes: country

ordered_available_debris - Iterate through all debris belong to available special projects of the scoped country - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
ordered_available_debris = {
	limit = { <triggers> }
	position = <integer, starting with 0>
	order_by = <variable>/trigger:<trigger>
	inverse = yes/no (default: no - if yes, then 0 is lowest rather than highest)
	<effects>
}
Supported Scopes: country

every_available_debris - Iterate through all debris belong to available special projects of the scoped country - executes the enclosed effects on all of them for which the limit triggers return true
every_available_debris = { limit = { <triggers> } <effects> }
Supported Scopes: country

random_pre_ftl_within_border - Iterate through all pre-ftl countries within the country's or sector's borders - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
random_pre_ftl_within_border = {
	limit = { <triggers> }
	weights = { (optional - adds weights to affect the chance a specific object is selected)
		base = float
		modifier = { <add/factor = float> <triggers> }
	}
	<effects>
}
Supported Scopes: country sector

ordered_pre_ftl_within_border - Iterate through all pre-ftl countries within the country's or sector's borders - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
ordered_pre_ftl_within_border = {
	limit = { <triggers> }
	position = <integer, starting with 0>
	order_by = <variable>/trigger:<trigger>
	inverse = yes/no (default: no - if yes, then 0 is lowest rather than highest)
	<effects>
}
Supported Scopes: country sector

every_pre_ftl_within_border - Iterate through all pre-ftl countries within the country's or sector's borders - executes the enclosed effects on all of them for which the limit triggers return true
every_pre_ftl_within_border = { limit = { <triggers> } <effects> }
Supported Scopes: country sector

random_observed_pre_ftl_within_border - Iterate through all pre-ftl countries with an observation post around their capital within the country's or sector's borders - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
random_observed_pre_ftl_within_border = {
	limit = { <triggers> }
	weights = { (optional - adds weights to affect the chance a specific object is selected)
		base = float
		modifier = { <add/factor = float> <triggers> }
	}
	<effects>
}
Supported Scopes: country sector

ordered_observed_pre_ftl_within_border - Iterate through all pre-ftl countries with an observation post around their capital within the country's or sector's borders - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
ordered_observed_pre_ftl_within_border = {
	limit = { <triggers> }
	position = <integer, starting with 0>
	order_by = <variable>/trigger:<trigger>
	inverse = yes/no (default: no - if yes, then 0 is lowest rather than highest)
	<effects>
}
Supported Scopes: country sector

every_observed_pre_ftl_within_border - Iterate through all pre-ftl countries with an observation post around their capital within the country's or sector's borders - executes the enclosed effects on all of them for which the limit triggers return true
every_observed_pre_ftl_within_border = { limit = { <triggers> } <effects> }
Supported Scopes: country sector

random_owned_design - Iterate through all designs owned by the current country - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
random_owned_design = {
	limit = { <triggers> }
	weights = { (optional - adds weights to affect the chance a specific object is selected)
		base = float
		modifier = { <add/factor = float> <triggers> }
	}
	<effects>
}
Supported Scopes: country

ordered_owned_design - Iterate through all designs owned by the current country - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
ordered_owned_design = {
	limit = { <triggers> }
	position = <integer, starting with 0>
	order_by = <variable>/trigger:<trigger>
	inverse = yes/no (default: no - if yes, then 0 is lowest rather than highest)
	<effects>
}
Supported Scopes: country

every_owned_design - Iterate through all designs owned by the current country - executes the enclosed effects on all of them for which the limit triggers return true
every_owned_design = { limit = { <triggers> } <effects> }
Supported Scopes: country

random_spynetwork - Iterate through each spynetwork - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
random_spynetwork = {
	limit = { <triggers> }
	weights = { (optional - adds weights to affect the chance a specific object is selected)
		base = float
		modifier = { <add/factor = float> <triggers> }
	}
	<effects>
}
Supported Scopes: country no_scope

ordered_spynetwork - Iterate through each spynetwork - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
ordered_spynetwork = {
	limit = { <triggers> }
	position = <integer, starting with 0>
	order_by = <variable>/trigger:<trigger>
	inverse = yes/no (default: no - if yes, then 0 is lowest rather than highest)
	<effects>
}
Supported Scopes: country no_scope

every_spynetwork - Iterate through each spynetwork - executes the enclosed effects on all of them for which the limit triggers return true
every_spynetwork = { limit = { <triggers> } <effects> }
Supported Scopes: country no_scope

random_espionage_operation - Iterate through each espionage operation - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
random_espionage_operation = {
	limit = { <triggers> }
	weights = { (optional - adds weights to affect the chance a specific object is selected)
		base = float
		modifier = { <add/factor = float> <triggers> }
	}
	<effects>
}
Supported Scopes: country no_scope spy_network

ordered_espionage_operation - Iterate through each espionage operation - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
ordered_espionage_operation = {
	limit = { <triggers> }
	position = <integer, starting with 0>
	order_by = <variable>/trigger:<trigger>
	inverse = yes/no (default: no - if yes, then 0 is lowest rather than highest)
	<effects>
}
Supported Scopes: country no_scope spy_network

every_espionage_operation - Iterate through each espionage operation - executes the enclosed effects on all of them for which the limit triggers return true
every_espionage_operation = { limit = { <triggers> } <effects> }
Supported Scopes: country no_scope spy_network

random_espionage_asset - Iterate through each espionage asset - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
random_espionage_asset = {
	limit = { <triggers> }
	weights = { (optional - adds weights to affect the chance a specific object is selected)
		base = float
		modifier = { <add/factor = float> <triggers> }
	}
	<effects>
}
Supported Scopes: no_scope spy_network espionage_operation

ordered_espionage_asset - Iterate through each espionage asset - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
ordered_espionage_asset = {
	limit = { <triggers> }
	position = <integer, starting with 0>
	order_by = <variable>/trigger:<trigger>
	inverse = yes/no (default: no - if yes, then 0 is lowest rather than highest)
	<effects>
}
Supported Scopes: no_scope spy_network espionage_operation

every_espionage_asset - Iterate through each espionage asset - executes the enclosed effects on all of them for which the limit triggers return true
every_espionage_asset = { limit = { <triggers> } <effects> }
Supported Scopes: no_scope spy_network espionage_operation

random_exhibit - Iterate through every exhibit - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
random_exhibit = {
	limit = { <triggers> }
	weights = { (optional - adds weights to affect the chance a specific object is selected)
		base = float
		modifier = { <add/factor = float> <triggers> }
	}
	<effects>
}
Supported Scopes: country

ordered_exhibit - Iterate through every exhibit - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
ordered_exhibit = {
	limit = { <triggers> }
	position = <integer, starting with 0>
	order_by = <variable>/trigger:<trigger>
	inverse = yes/no (default: no - if yes, then 0 is lowest rather than highest)
	<effects>
}
Supported Scopes: country

every_exhibit - Iterate through every exhibit - executes the enclosed effects on all of them for which the limit triggers return true
every_exhibit = { limit = { <triggers> } <effects> }
Supported Scopes: country

random_federation - Iterate through each federation - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
random_federation = {
	limit = { <triggers> }
	weights = { (optional - adds weights to affect the chance a specific object is selected)
		base = float
		modifier = { <add/factor = float> <triggers> }
	}
	<effects>
}
Supported Scopes: all

ordered_federation - Iterate through each federation - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
ordered_federation = {
	limit = { <triggers> }
	position = <integer, starting with 0>
	order_by = <variable>/trigger:<trigger>
	inverse = yes/no (default: no - if yes, then 0 is lowest rather than highest)
	<effects>
}
Supported Scopes: all

every_federation - Iterate through each federation - executes the enclosed effects on all of them for which the limit triggers return true
every_federation = { limit = { <triggers> } <effects> }
Supported Scopes: all

random_first_contact - Iterate through each first contact (both active and complete) that this country is engaging in - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
random_first_contact = {
	limit = { <triggers> }
	weights = { (optional - adds weights to affect the chance a specific object is selected)
		base = float
		modifier = { <add/factor = float> <triggers> }
	}
	<effects>
}
Supported Scopes: country

ordered_first_contact - Iterate through each first contact (both active and complete) that this country is engaging in - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
ordered_first_contact = {
	limit = { <triggers> }
	position = <integer, starting with 0>
	order_by = <variable>/trigger:<trigger>
	inverse = yes/no (default: no - if yes, then 0 is lowest rather than highest)
	<effects>
}
Supported Scopes: country

every_first_contact - Iterate through each first contact (both active and complete) that this country is engaging in - executes the enclosed effects on all of them for which the limit triggers return true
every_first_contact = { limit = { <triggers> } <effects> }
Supported Scopes: country

random_active_first_contact - Iterate through each active (non-completed) first contact that this country is engaging in - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
random_active_first_contact = {
	limit = { <triggers> }
	weights = { (optional - adds weights to affect the chance a specific object is selected)
		base = float
		modifier = { <add/factor = float> <triggers> }
	}
	<effects>
}
Supported Scopes: country

ordered_active_first_contact - Iterate through each active (non-completed) first contact that this country is engaging in - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
ordered_active_first_contact = {
	limit = { <triggers> }
	position = <integer, starting with 0>
	order_by = <variable>/trigger:<trigger>
	inverse = yes/no (default: no - if yes, then 0 is lowest rather than highest)
	<effects>
}
Supported Scopes: country

every_active_first_contact - Iterate through each active (non-completed) first contact that this country is engaging in - executes the enclosed effects on all of them for which the limit triggers return true
every_active_first_contact = { limit = { <triggers> } <effects> }
Supported Scopes: country

random_galaxy_fleet - Iterate through each fleet in the entire game - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
random_galaxy_fleet = {
	limit = { <triggers> }
	weights = { (optional - adds weights to affect the chance a specific object is selected)
		base = float
		modifier = { <add/factor = float> <triggers> }
	}
	<effects>
}
Supported Scopes: all

ordered_galaxy_fleet - Iterate through each fleet in the entire game - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
ordered_galaxy_fleet = {
	limit = { <triggers> }
	position = <integer, starting with 0>
	order_by = <variable>/trigger:<trigger>
	inverse = yes/no (default: no - if yes, then 0 is lowest rather than highest)
	<effects>
}
Supported Scopes: all

every_galaxy_fleet - Iterate through each fleet in the entire game - executes the enclosed effects on all of them for which the limit triggers return true
every_galaxy_fleet = { limit = { <triggers> } <effects> }
Supported Scopes: all

random_combatant_fleet - Iterate through each fleet this fleet is in combat with - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
random_combatant_fleet = {
	limit = { <triggers> }
	weights = { (optional - adds weights to affect the chance a specific object is selected)
		base = float
		modifier = { <add/factor = float> <triggers> }
	}
	<effects>
}
Supported Scopes: fleet

ordered_combatant_fleet - Iterate through each fleet this fleet is in combat with - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
ordered_combatant_fleet = {
	limit = { <triggers> }
	position = <integer, starting with 0>
	order_by = <variable>/trigger:<trigger>
	inverse = yes/no (default: no - if yes, then 0 is lowest rather than highest)
	<effects>
}
Supported Scopes: fleet

every_combatant_fleet - Iterate through each fleet this fleet is in combat with - executes the enclosed effects on all of them for which the limit triggers return true
every_combatant_fleet = { limit = { <triggers> } <effects> }
Supported Scopes: fleet

random_fleet_in_system - Iterate through each fleet in the current system - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
random_fleet_in_system = {
	limit = { <triggers> }
	weights = { (optional - adds weights to affect the chance a specific object is selected)
		base = float
		modifier = { <add/factor = float> <triggers> }
	}
	<effects>
}
Supported Scopes: galactic_object

ordered_fleet_in_system - Iterate through each fleet in the current system - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
ordered_fleet_in_system = {
	limit = { <triggers> }
	position = <integer, starting with 0>
	order_by = <variable>/trigger:<trigger>
	inverse = yes/no (default: no - if yes, then 0 is lowest rather than highest)
	<effects>
}
Supported Scopes: galactic_object

every_fleet_in_system - Iterate through each fleet in the current system - executes the enclosed effects on all of them for which the limit triggers return true
every_fleet_in_system = { limit = { <triggers> } <effects> }
Supported Scopes: galactic_object

random_owned_fleet - Iterate through each fleet owned by the country - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
random_owned_fleet = {
	limit = { <triggers> }
	weights = { (optional - adds weights to affect the chance a specific object is selected)
		base = float
		modifier = { <add/factor = float> <triggers> }
	}
	<effects>
}
Supported Scopes: country

ordered_owned_fleet - Iterate through each fleet owned by the country - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
ordered_owned_fleet = {
	limit = { <triggers> }
	position = <integer, starting with 0>
	order_by = <variable>/trigger:<trigger>
	inverse = yes/no (default: no - if yes, then 0 is lowest rather than highest)
	<effects>
}
Supported Scopes: country

every_owned_fleet - Iterate through each fleet owned by the country - executes the enclosed effects on all of them for which the limit triggers return true
every_owned_fleet = { limit = { <triggers> } <effects> }
Supported Scopes: country

random_controlled_fleet - Iterate through each fleet controlled by the country - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
random_controlled_fleet = {
	limit = { <triggers> }
	weights = { (optional - adds weights to affect the chance a specific object is selected)
		base = float
		modifier = { <add/factor = float> <triggers> }
	}
	<effects>
}
Supported Scopes: country

ordered_controlled_fleet - Iterate through each fleet controlled by the country - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
ordered_controlled_fleet = {
	limit = { <triggers> }
	position = <integer, starting with 0>
	order_by = <variable>/trigger:<trigger>
	inverse = yes/no (default: no - if yes, then 0 is lowest rather than highest)
	<effects>
}
Supported Scopes: country

every_controlled_fleet - Iterate through each fleet controlled by the country - executes the enclosed effects on all of them for which the limit triggers return true
every_controlled_fleet = { limit = { <triggers> } <effects> }
Supported Scopes: country

random_fleet_in_orbit - Iterate through each fleet orbiting the current planet/starbase/megastructure - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
random_fleet_in_orbit = {
	limit = { <triggers> }
	weights = { (optional - adds weights to affect the chance a specific object is selected)
		base = float
		modifier = { <add/factor = float> <triggers> }
	}
	<effects>
}
Supported Scopes: megastructure planet starbase

ordered_fleet_in_orbit - Iterate through each fleet orbiting the current planet/starbase/megastructure - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
ordered_fleet_in_orbit = {
	limit = { <triggers> }
	position = <integer, starting with 0>
	order_by = <variable>/trigger:<trigger>
	inverse = yes/no (default: no - if yes, then 0 is lowest rather than highest)
	<effects>
}
Supported Scopes: megastructure planet starbase

every_fleet_in_orbit - Iterate through each fleet orbiting the current planet/starbase/megastructure - executes the enclosed effects on all of them for which the limit triggers return true
every_fleet_in_orbit = { limit = { <triggers> } <effects> }
Supported Scopes: megastructure planet starbase

random_orbital_station - Iterate through each orbital station owned by the current country or in the current system - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
random_orbital_station = {
	limit = { <triggers> }
	weights = { (optional - adds weights to affect the chance a specific object is selected)
		base = float
		modifier = { <add/factor = float> <triggers> }
	}
	<effects>
}
Supported Scopes: country galactic_object

ordered_orbital_station - Iterate through each orbital station owned by the current country or in the current system - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
ordered_orbital_station = {
	limit = { <triggers> }
	position = <integer, starting with 0>
	order_by = <variable>/trigger:<trigger>
	inverse = yes/no (default: no - if yes, then 0 is lowest rather than highest)
	<effects>
}
Supported Scopes: country galactic_object

every_orbital_station - Iterate through each orbital station owned by the current country or in the current system - executes the enclosed effects on all of them for which the limit triggers return true
every_orbital_station = { limit = { <triggers> } <effects> }
Supported Scopes: country galactic_object

random_galcom_member - Iterate through each member of the galactic community - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
random_galcom_member = {
	limit = { <triggers> }
	weights = { (optional - adds weights to affect the chance a specific object is selected)
		base = float
		modifier = { <add/factor = float> <triggers> }
	}
	<effects>
}
Supported Scopes: all

ordered_galcom_member - Iterate through each member of the galactic community - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
ordered_galcom_member = {
	limit = { <triggers> }
	position = <integer, starting with 0>
	order_by = <variable>/trigger:<trigger>
	inverse = yes/no (default: no - if yes, then 0 is lowest rather than highest)
	<effects>
}
Supported Scopes: all

every_galcom_member - Iterate through each member of the galactic community - executes the enclosed effects on all of them for which the limit triggers return true
every_galcom_member = { limit = { <triggers> } <effects> }
Supported Scopes: all

random_council_member - Iterate through each member of the galactic council - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
random_council_member = {
	limit = { <triggers> }
	weights = { (optional - adds weights to affect the chance a specific object is selected)
		base = float
		modifier = { <add/factor = float> <triggers> }
	}
	<effects>
}
Supported Scopes: all

ordered_council_member - Iterate through each member of the galactic council - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
ordered_council_member = {
	limit = { <triggers> }
	position = <integer, starting with 0>
	order_by = <variable>/trigger:<trigger>
	inverse = yes/no (default: no - if yes, then 0 is lowest rather than highest)
	<effects>
}
Supported Scopes: all

every_council_member - Iterate through each member of the galactic council - executes the enclosed effects on all of them for which the limit triggers return true
every_council_member = { limit = { <triggers> } <effects> }
Supported Scopes: all

random_owned_leader - Iterate through each leader that is owned by the country - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
random_owned_leader = {
	limit = { <triggers> }
	weights = { (optional - adds weights to affect the chance a specific object is selected)
		base = float
		modifier = { <add/factor = float> <triggers> }
	}
	<effects>
}
Supported Scopes: country

ordered_owned_leader - Iterate through each leader that is owned by the country - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
ordered_owned_leader = {
	limit = { <triggers> }
	position = <integer, starting with 0>
	order_by = <variable>/trigger:<trigger>
	inverse = yes/no (default: no - if yes, then 0 is lowest rather than highest)
	<effects>
}
Supported Scopes: country

every_owned_leader - Iterate through each leader that is owned by the country - executes the enclosed effects on all of them for which the limit triggers return true
every_owned_leader = { limit = { <triggers> } <effects> }
Supported Scopes: country

random_pool_leader - Iterate through each leader that is recruitable for the country - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
random_pool_leader = {
	limit = { <triggers> }
	weights = { (optional - adds weights to affect the chance a specific object is selected)
		base = float
		modifier = { <add/factor = float> <triggers> }
	}
	<effects>
}
Supported Scopes: country

ordered_pool_leader - Iterate through each leader that is recruitable for the country - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
ordered_pool_leader = {
	limit = { <triggers> }
	position = <integer, starting with 0>
	order_by = <variable>/trigger:<trigger>
	inverse = yes/no (default: no - if yes, then 0 is lowest rather than highest)
	<effects>
}
Supported Scopes: country

every_pool_leader - Iterate through each leader that is recruitable for the country - executes the enclosed effects on all of them for which the limit triggers return true
every_pool_leader = { limit = { <triggers> } <effects> }
Supported Scopes: country

random_envoy - Iterate through each envoy available to the country - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
random_envoy = {
	limit = { <triggers> }
	weights = { (optional - adds weights to affect the chance a specific object is selected)
		base = float
		modifier = { <add/factor = float> <triggers> }
	}
	<effects>
}
Supported Scopes: country

ordered_envoy - Iterate through each envoy available to the country - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
ordered_envoy = {
	limit = { <triggers> }
	position = <integer, starting with 0>
	order_by = <variable>/trigger:<trigger>
	inverse = yes/no (default: no - if yes, then 0 is lowest rather than highest)
	<effects>
}
Supported Scopes: country

every_envoy - Iterate through each envoy available to the country - executes the enclosed effects on all of them for which the limit triggers return true
every_envoy = { limit = { <triggers> } <effects> }
Supported Scopes: country

random_megastructure - Iterate through each megastructure - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
random_megastructure = {
	limit = { <triggers> }
	weights = { (optional - adds weights to affect the chance a specific object is selected)
		base = float
		modifier = { <add/factor = float> <triggers> }
	}
	<effects>
}
Supported Scopes: all

ordered_megastructure - Iterate through each megastructure - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
ordered_megastructure = {
	limit = { <triggers> }
	position = <integer, starting with 0>
	order_by = <variable>/trigger:<trigger>
	inverse = yes/no (default: no - if yes, then 0 is lowest rather than highest)
	<effects>
}
Supported Scopes: all

every_megastructure - Iterate through each megastructure - executes the enclosed effects on all of them for which the limit triggers return true
every_megastructure = { limit = { <triggers> } <effects> }
Supported Scopes: all

random_owned_megastructure - Iterate through each owned megastructure - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
random_owned_megastructure = {
	limit = { <triggers> }
	weights = { (optional - adds weights to affect the chance a specific object is selected)
		base = float
		modifier = { <add/factor = float> <triggers> }
	}
	<effects>
}
Supported Scopes: country

ordered_owned_megastructure - Iterate through each owned megastructure - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
ordered_owned_megastructure = {
	limit = { <triggers> }
	position = <integer, starting with 0>
	order_by = <variable>/trigger:<trigger>
	inverse = yes/no (default: no - if yes, then 0 is lowest rather than highest)
	<effects>
}
Supported Scopes: country

every_owned_megastructure - Iterate through each owned megastructure - executes the enclosed effects on all of them for which the limit triggers return true
every_owned_megastructure = { limit = { <triggers> } <effects> }
Supported Scopes: country

random_system_megastructure - Iterate through each megastructure in system - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
random_system_megastructure = {
	limit = { <triggers> }
	weights = { (optional - adds weights to affect the chance a specific object is selected)
		base = float
		modifier = { <add/factor = float> <triggers> }
	}
	<effects>
}
Supported Scopes: all

ordered_system_megastructure - Iterate through each megastructure in system - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
ordered_system_megastructure = {
	limit = { <triggers> }
	position = <integer, starting with 0>
	order_by = <variable>/trigger:<trigger>
	inverse = yes/no (default: no - if yes, then 0 is lowest rather than highest)
	<effects>
}
Supported Scopes: all

every_system_megastructure - Iterate through each megastructure in system - executes the enclosed effects on all of them for which the limit triggers return true
every_system_megastructure = { limit = { <triggers> } <effects> }
Supported Scopes: all

random_member - Iterate through each member of the federation - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
random_member = {
	limit = { <triggers> }
	weights = { (optional - adds weights to affect the chance a specific object is selected)
		base = float
		modifier = { <add/factor = float> <triggers> }
	}
	<effects>
}
Supported Scopes: federation

ordered_member - Iterate through each member of the federation - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
ordered_member = {
	limit = { <triggers> }
	position = <integer, starting with 0>
	order_by = <variable>/trigger:<trigger>
	inverse = yes/no (default: no - if yes, then 0 is lowest rather than highest)
	<effects>
}
Supported Scopes: federation

every_member - Iterate through each member of the federation - executes the enclosed effects on all of them for which the limit triggers return true
every_member = { limit = { <triggers> } <effects> }
Supported Scopes: federation

random_associate - Iterate through each associate member of the federation - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
random_associate = {
	limit = { <triggers> }
	weights = { (optional - adds weights to affect the chance a specific object is selected)
		base = float
		modifier = { <add/factor = float> <triggers> }
	}
	<effects>
}
Supported Scopes: federation

ordered_associate - Iterate through each associate member of the federation - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
ordered_associate = {
	limit = { <triggers> }
	position = <integer, starting with 0>
	order_by = <variable>/trigger:<trigger>
	inverse = yes/no (default: no - if yes, then 0 is lowest rather than highest)
	<effects>
}
Supported Scopes: federation

every_associate - Iterate through each associate member of the federation - executes the enclosed effects on all of them for which the limit triggers return true
every_associate = { limit = { <triggers> } <effects> }
Supported Scopes: federation

random_system_planet - Iterate through each planet (colony or not) in the current system - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
random_system_planet = {
	limit = { <triggers> }
	weights = { (optional - adds weights to affect the chance a specific object is selected)
		base = float
		modifier = { <add/factor = float> <triggers> }
	}
	<effects>
}
Supported Scopes: galactic_object

ordered_system_planet - Iterate through each planet (colony or not) in the current system - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
ordered_system_planet = {
	limit = { <triggers> }
	position = <integer, starting with 0>
	order_by = <variable>/trigger:<trigger>
	inverse = yes/no (default: no - if yes, then 0 is lowest rather than highest)
	<effects>
}
Supported Scopes: galactic_object

every_system_planet - Iterate through each planet (colony or not) in the current system - executes the enclosed effects on all of them for which the limit triggers return true
every_system_planet = { limit = { <triggers> } <effects> }
Supported Scopes: galactic_object

random_system_colony - Iterate through each colony in the current system - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
random_system_colony = {
	limit = { <triggers> }
	weights = { (optional - adds weights to affect the chance a specific object is selected)
		base = float
		modifier = { <add/factor = float> <triggers> }
	}
	<effects>
}
Supported Scopes: galactic_object

ordered_system_colony - Iterate through each colony in the current system - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
ordered_system_colony = {
	limit = { <triggers> }
	position = <integer, starting with 0>
	order_by = <variable>/trigger:<trigger>
	inverse = yes/no (default: no - if yes, then 0 is lowest rather than highest)
	<effects>
}
Supported Scopes: galactic_object

every_system_colony - Iterate through each colony in the current system - executes the enclosed effects on all of them for which the limit triggers return true
every_system_colony = { limit = { <triggers> } <effects> }
Supported Scopes: galactic_object

random_planet_within_border - Iterate through each planet within the current empire's borders - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
random_planet_within_border = {
	limit = { <triggers> }
	weights = { (optional - adds weights to affect the chance a specific object is selected)
		base = float
		modifier = { <add/factor = float> <triggers> }
	}
	<effects>
}
Supported Scopes: country

ordered_planet_within_border - Iterate through each planet within the current empire's borders - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
ordered_planet_within_border = {
	limit = { <triggers> }
	position = <integer, starting with 0>
	order_by = <variable>/trigger:<trigger>
	inverse = yes/no (default: no - if yes, then 0 is lowest rather than highest)
	<effects>
}
Supported Scopes: country

every_planet_within_border - Iterate through each planet within the current empire's borders - executes the enclosed effects on all of them for which the limit triggers return true
every_planet_within_border = { limit = { <triggers> } <effects> }
Supported Scopes: country

random_owned_planet - Iterate through each inhabited planet owned by the current empire - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
random_owned_planet = {
	limit = { <triggers> }
	weights = { (optional - adds weights to affect the chance a specific object is selected)
		base = float
		modifier = { <add/factor = float> <triggers> }
	}
	<effects>
}
Supported Scopes: country sector

ordered_owned_planet - Iterate through each inhabited planet owned by the current empire - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
ordered_owned_planet = {
	limit = { <triggers> }
	position = <integer, starting with 0>
	order_by = <variable>/trigger:<trigger>
	inverse = yes/no (default: no - if yes, then 0 is lowest rather than highest)
	<effects>
}
Supported Scopes: country sector

every_owned_planet - Iterate through each inhabited planet owned by the current empire - executes the enclosed effects on all of them for which the limit triggers return true
every_owned_planet = { limit = { <triggers> } <effects> }
Supported Scopes: country sector

random_controlled_planet - Iterate through each inhabited planet controlled by the current empire - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
random_controlled_planet = {
	limit = { <triggers> }
	weights = { (optional - adds weights to affect the chance a specific object is selected)
		base = float
		modifier = { <add/factor = float> <triggers> }
	}
	<effects>
}
Supported Scopes: country

ordered_controlled_planet - Iterate through each inhabited planet controlled by the current empire - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
ordered_controlled_planet = {
	limit = { <triggers> }
	position = <integer, starting with 0>
	order_by = <variable>/trigger:<trigger>
	inverse = yes/no (default: no - if yes, then 0 is lowest rather than highest)
	<effects>
}
Supported Scopes: country

every_controlled_planet - Iterate through each inhabited planet controlled by the current empire - executes the enclosed effects on all of them for which the limit triggers return true
every_controlled_planet = { limit = { <triggers> } <effects> }
Supported Scopes: country

random_galaxy_planet - Iterate through each planet ANYWHERE in the game; warning: resource intensive! - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
random_galaxy_planet = {
	limit = { <triggers> }
	weights = { (optional - adds weights to affect the chance a specific object is selected)
		base = float
		modifier = { <add/factor = float> <triggers> }
	}
	<effects>
}
Supported Scopes: all

ordered_galaxy_planet - Iterate through each planet ANYWHERE in the game; warning: resource intensive! - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
ordered_galaxy_planet = {
	limit = { <triggers> }
	position = <integer, starting with 0>
	order_by = <variable>/trigger:<trigger>
	inverse = yes/no (default: no - if yes, then 0 is lowest rather than highest)
	<effects>
}
Supported Scopes: all

every_galaxy_planet - Iterate through each planet ANYWHERE in the game; warning: resource intensive! - executes the enclosed effects on all of them for which the limit triggers return true
every_galaxy_planet = { limit = { <triggers> } <effects> }
Supported Scopes: all

random_deposit - Iterate through each deposit on the planet - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
random_deposit = {
	limit = { <triggers> }
	weights = { (optional - adds weights to affect the chance a specific object is selected)
		base = float
		modifier = { <add/factor = float> <triggers> }
	}
	<effects>
}
Supported Scopes: planet

ordered_deposit - Iterate through each deposit on the planet - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
ordered_deposit = {
	limit = { <triggers> }
	position = <integer, starting with 0>
	order_by = <variable>/trigger:<trigger>
	inverse = yes/no (default: no - if yes, then 0 is lowest rather than highest)
	<effects>
}
Supported Scopes: planet

every_deposit - Iterate through each deposit on the planet - executes the enclosed effects on all of them for which the limit triggers return true
every_deposit = { limit = { <triggers> } <effects> }
Supported Scopes: planet

random_moon - Iterate through each moon of the planet - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
random_moon = {
	limit = { <triggers> }
	weights = { (optional - adds weights to affect the chance a specific object is selected)
		base = float
		modifier = { <add/factor = float> <triggers> }
	}
	<effects>
}
Supported Scopes: planet

ordered_moon - Iterate through each moon of the planet - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
ordered_moon = {
	limit = { <triggers> }
	position = <integer, starting with 0>
	order_by = <variable>/trigger:<trigger>
	inverse = yes/no (default: no - if yes, then 0 is lowest rather than highest)
	<effects>
}
Supported Scopes: planet

every_moon - Iterate through each moon of the planet - executes the enclosed effects on all of them for which the limit triggers return true
every_moon = { limit = { <triggers> } <effects> }
Supported Scopes: planet

random_owned_pop - Iterate through all owned pops - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
random_owned_pop = {
	limit = { <triggers> }
	weights = { (optional - adds weights to affect the chance a specific object is selected)
		base = float
		modifier = { <add/factor = float> <triggers> }
	}
	<effects>
}
Supported Scopes: planet country pop_faction sector

ordered_owned_pop - Iterate through all owned pops - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
ordered_owned_pop = {
	limit = { <triggers> }
	position = <integer, starting with 0>
	order_by = <variable>/trigger:<trigger>
	inverse = yes/no (default: no - if yes, then 0 is lowest rather than highest)
	<effects>
}
Supported Scopes: planet country pop_faction sector

every_owned_pop - Iterate through all owned pops - executes the enclosed effects on all of them for which the limit triggers return true
every_owned_pop = { limit = { <triggers> } <effects> }
Supported Scopes: planet country pop_faction sector

random_pop_faction - Iterate through all the country's pop factions - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
random_pop_faction = {
	limit = { <triggers> }
	weights = { (optional - adds weights to affect the chance a specific object is selected)
		base = float
		modifier = { <add/factor = float> <triggers> }
	}
	<effects>
}
Supported Scopes: country

ordered_pop_faction - Iterate through all the country's pop factions - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
ordered_pop_faction = {
	limit = { <triggers> }
	position = <integer, starting with 0>
	order_by = <variable>/trigger:<trigger>
	inverse = yes/no (default: no - if yes, then 0 is lowest rather than highest)
	<effects>
}
Supported Scopes: country

every_pop_faction - Iterate through all the country's pop factions - executes the enclosed effects on all of them for which the limit triggers return true
every_pop_faction = { limit = { <triggers> } <effects> }
Supported Scopes: country

random_owned_pop_group - Iterate through all owned pop groups - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
random_owned_pop_group = {
	limit = { <triggers> }
	weights = { (optional - adds weights to affect the chance a specific object is selected)
		base = float
		modifier = { <add/factor = float> <triggers> }
	}
	<effects>
}
Supported Scopes: planet country pop_faction sector

ordered_owned_pop_group - Iterate through all owned pop groups - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
ordered_owned_pop_group = {
	limit = { <triggers> }
	position = <integer, starting with 0>
	order_by = <variable>/trigger:<trigger>
	inverse = yes/no (default: no - if yes, then 0 is lowest rather than highest)
	<effects>
}
Supported Scopes: planet country pop_faction sector

every_owned_pop_group - Iterate through all owned pop groups - executes the enclosed effects on all of them for which the limit triggers return true
every_owned_pop_group = { limit = { <triggers> } <effects> }
Supported Scopes: planet country pop_faction sector

random_species_pop_group - Iterate through each pop group that belongs to this species; warning: resource-intensive! - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
random_species_pop_group = {
	limit = { <triggers> }
	weights = { (optional - adds weights to affect the chance a specific object is selected)
		base = float
		modifier = { <add/factor = float> <triggers> }
	}
	<effects>
}
Supported Scopes: species

ordered_species_pop_group - Iterate through each pop group that belongs to this species; warning: resource-intensive! - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
ordered_species_pop_group = {
	limit = { <triggers> }
	position = <integer, starting with 0>
	order_by = <variable>/trigger:<trigger>
	inverse = yes/no (default: no - if yes, then 0 is lowest rather than highest)
	<effects>
}
Supported Scopes: species

every_species_pop_group - Iterate through each pop group that belongs to this species; warning: resource-intensive! - executes the enclosed effects on all of them for which the limit triggers return true
every_species_pop_group = { limit = { <triggers> } <effects> }
Supported Scopes: species

random_owned_pop_job - Iterate through all owned pop jobs - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
random_owned_pop_job = {
	limit = { <triggers> }
	weights = { (optional - adds weights to affect the chance a specific object is selected)
		base = float
		modifier = { <add/factor = float> <triggers> }
	}
	<effects>
}
Supported Scopes: planet country sector

ordered_owned_pop_job - Iterate through all owned pop jobs - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
ordered_owned_pop_job = {
	limit = { <triggers> }
	position = <integer, starting with 0>
	order_by = <variable>/trigger:<trigger>
	inverse = yes/no (default: no - if yes, then 0 is lowest rather than highest)
	<effects>
}
Supported Scopes: planet country sector

every_owned_pop_job - Iterate through all owned pop jobs - executes the enclosed effects on all of them for which the limit triggers return true
every_owned_pop_job = { limit = { <triggers> } <effects> }
Supported Scopes: planet country sector

random_galaxy_sector - Iterate through all sectors in the game - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
random_galaxy_sector = {
	limit = { <triggers> }
	weights = { (optional - adds weights to affect the chance a specific object is selected)
		base = float
		modifier = { <add/factor = float> <triggers> }
	}
	<effects>
}
Supported Scopes: all

ordered_galaxy_sector - Iterate through all sectors in the game - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
ordered_galaxy_sector = {
	limit = { <triggers> }
	position = <integer, starting with 0>
	order_by = <variable>/trigger:<trigger>
	inverse = yes/no (default: no - if yes, then 0 is lowest rather than highest)
	<effects>
}
Supported Scopes: all

every_galaxy_sector - Iterate through all sectors in the game - executes the enclosed effects on all of them for which the limit triggers return true
every_galaxy_sector = { limit = { <triggers> } <effects> }
Supported Scopes: all

random_owned_sector - Iterate through every owned sector - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
random_owned_sector = {
	limit = { <triggers> }
	weights = { (optional - adds weights to affect the chance a specific object is selected)
		base = float
		modifier = { <add/factor = float> <triggers> }
	}
	<effects>
}
Supported Scopes: country

ordered_owned_sector - Iterate through every owned sector - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
ordered_owned_sector = {
	limit = { <triggers> }
	position = <integer, starting with 0>
	order_by = <variable>/trigger:<trigger>
	inverse = yes/no (default: no - if yes, then 0 is lowest rather than highest)
	<effects>
}
Supported Scopes: country

every_owned_sector - Iterate through every owned sector - executes the enclosed effects on all of them for which the limit triggers return true
every_owned_sector = { limit = { <triggers> } <effects> }
Supported Scopes: country

random_owned_ship - Iterate through each ship in the fleet or controlled by the country - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
random_owned_ship = {
	limit = { <triggers> }
	weights = { (optional - adds weights to affect the chance a specific object is selected)
		base = float
		modifier = { <add/factor = float> <triggers> }
	}
	<effects>
}
Supported Scopes: country fleet

ordered_owned_ship - Iterate through each ship in the fleet or controlled by the country - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
ordered_owned_ship = {
	limit = { <triggers> }
	position = <integer, starting with 0>
	order_by = <variable>/trigger:<trigger>
	inverse = yes/no (default: no - if yes, then 0 is lowest rather than highest)
	<effects>
}
Supported Scopes: country fleet

every_owned_ship - Iterate through each ship in the fleet or controlled by the country - executes the enclosed effects on all of them for which the limit triggers return true
every_owned_ship = { limit = { <triggers> } <effects> }
Supported Scopes: country fleet

random_controlled_ship - Iterate through each ship in the fleet or controlled by the country - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
random_controlled_ship = {
	limit = { <triggers> }
	weights = { (optional - adds weights to affect the chance a specific object is selected)
		base = float
		modifier = { <add/factor = float> <triggers> }
	}
	<effects>
}
Supported Scopes: country fleet

ordered_controlled_ship - Iterate through each ship in the fleet or controlled by the country - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
ordered_controlled_ship = {
	limit = { <triggers> }
	position = <integer, starting with 0>
	order_by = <variable>/trigger:<trigger>
	inverse = yes/no (default: no - if yes, then 0 is lowest rather than highest)
	<effects>
}
Supported Scopes: country fleet

every_controlled_ship - Iterate through each ship in the fleet or controlled by the country - executes the enclosed effects on all of them for which the limit triggers return true
every_controlled_ship = { limit = { <triggers> } <effects> }
Supported Scopes: country fleet

random_ship_in_system - Iterate through each ship in the current system - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
random_ship_in_system = {
	limit = { <triggers> }
	weights = { (optional - adds weights to affect the chance a specific object is selected)
		base = float
		modifier = { <add/factor = float> <triggers> }
	}
	<effects>
}
Supported Scopes: galactic_object

ordered_ship_in_system - Iterate through each ship in the current system - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
ordered_ship_in_system = {
	limit = { <triggers> }
	position = <integer, starting with 0>
	order_by = <variable>/trigger:<trigger>
	inverse = yes/no (default: no - if yes, then 0 is lowest rather than highest)
	<effects>
}
Supported Scopes: galactic_object

every_ship_in_system - Iterate through each ship in the current system - executes the enclosed effects on all of them for which the limit triggers return true
every_ship_in_system = { limit = { <triggers> } <effects> }
Supported Scopes: galactic_object

random_situation - Iterate through each situation a country is experiencing - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
random_situation = {
	limit = { <triggers> }
	weights = { (optional - adds weights to affect the chance a specific object is selected)
		base = float
		modifier = { <add/factor = float> <triggers> }
	}
	<effects>
}
Supported Scopes: country

ordered_situation - Iterate through each situation a country is experiencing - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
ordered_situation = {
	limit = { <triggers> }
	position = <integer, starting with 0>
	order_by = <variable>/trigger:<trigger>
	inverse = yes/no (default: no - if yes, then 0 is lowest rather than highest)
	<effects>
}
Supported Scopes: country

every_situation - Iterate through each situation a country is experiencing - executes the enclosed effects on all of them for which the limit triggers return true
every_situation = { limit = { <triggers> } <effects> }
Supported Scopes: country

random_targeting_situation - Iterate through each situation that is targeting the current planet - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
random_targeting_situation = {
	limit = { <triggers> }
	weights = { (optional - adds weights to affect the chance a specific object is selected)
		base = float
		modifier = { <add/factor = float> <triggers> }
	}
	<effects>
}
Supported Scopes: planet

ordered_targeting_situation - Iterate through each situation that is targeting the current planet - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
ordered_targeting_situation = {
	limit = { <triggers> }
	position = <integer, starting with 0>
	order_by = <variable>/trigger:<trigger>
	inverse = yes/no (default: no - if yes, then 0 is lowest rather than highest)
	<effects>
}
Supported Scopes: planet

every_targeting_situation - Iterate through each situation that is targeting the current planet - executes the enclosed effects on all of them for which the limit triggers return true
every_targeting_situation = { limit = { <triggers> } <effects> }
Supported Scopes: planet

random_owned_pop_species - Iterate through each species of a country's owned pops - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
random_owned_pop_species = {
	limit = { <triggers> }
	weights = { (optional - adds weights to affect the chance a specific object is selected)
		base = float
		modifier = { <add/factor = float> <triggers> }
	}
	<effects>
}
Supported Scopes: country

ordered_owned_pop_species - Iterate through each species of a country's owned pops - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
ordered_owned_pop_species = {
	limit = { <triggers> }
	position = <integer, starting with 0>
	order_by = <variable>/trigger:<trigger>
	inverse = yes/no (default: no - if yes, then 0 is lowest rather than highest)
	<effects>
}
Supported Scopes: country

every_owned_pop_species - Iterate through each species of a country's owned pops - executes the enclosed effects on all of them for which the limit triggers return true
every_owned_pop_species = { limit = { <triggers> } <effects> }
Supported Scopes: country

random_galaxy_species - Check if any species in the galaxy meet the specified criteria - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
random_galaxy_species = {
	limit = { <triggers> }
	weights = { (optional - adds weights to affect the chance a specific object is selected)
		base = float
		modifier = { <add/factor = float> <triggers> }
	}
	<effects>
}
Supported Scopes: all

ordered_galaxy_species - Check if any species in the galaxy meet the specified criteria - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
ordered_galaxy_species = {
	limit = { <triggers> }
	position = <integer, starting with 0>
	order_by = <variable>/trigger:<trigger>
	inverse = yes/no (default: no - if yes, then 0 is lowest rather than highest)
	<effects>
}
Supported Scopes: all

every_galaxy_species - Check if any species in the galaxy meet the specified criteria - executes the enclosed effects on all of them for which the limit triggers return true
every_galaxy_species = { limit = { <triggers> } <effects> }
Supported Scopes: all

random_owned_species - Check if any of the species <on the planet/in the country> meet the specified criteria - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
random_owned_species = {
	limit = { <triggers> }
	weights = { (optional - adds weights to affect the chance a specific object is selected)
		base = float
		modifier = { <add/factor = float> <triggers> }
	}
	<effects>
}
Supported Scopes: planet country

ordered_owned_species - Check if any of the species <on the planet/in the country> meet the specified criteria - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
ordered_owned_species = {
	limit = { <triggers> }
	position = <integer, starting with 0>
	order_by = <variable>/trigger:<trigger>
	inverse = yes/no (default: no - if yes, then 0 is lowest rather than highest)
	<effects>
}
Supported Scopes: planet country

every_owned_species - Check if any of the species <on the planet/in the country> meet the specified criteria - executes the enclosed effects on all of them for which the limit triggers return true
every_owned_species = { limit = { <triggers> } <effects> }
Supported Scopes: planet country

random_enslaved_species - Check if any of the species with enslaved pops <on the planet/in the country> meet the specified criteria - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
random_enslaved_species = {
	limit = { <triggers> }
	weights = { (optional - adds weights to affect the chance a specific object is selected)
		base = float
		modifier = { <add/factor = float> <triggers> }
	}
	<effects>
}
Supported Scopes: planet country

ordered_enslaved_species - Check if any of the species with enslaved pops <on the planet/in the country> meet the specified criteria - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
ordered_enslaved_species = {
	limit = { <triggers> }
	position = <integer, starting with 0>
	order_by = <variable>/trigger:<trigger>
	inverse = yes/no (default: no - if yes, then 0 is lowest rather than highest)
	<effects>
}
Supported Scopes: planet country

every_enslaved_species - Check if any of the species with enslaved pops <on the planet/in the country> meet the specified criteria - executes the enclosed effects on all of them for which the limit triggers return true
every_enslaved_species = { limit = { <triggers> } <effects> }
Supported Scopes: planet country

random_owned_starbase - Iterate through every owned primary starbase - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
random_owned_starbase = {
	limit = { <triggers> }
	weights = { (optional - adds weights to affect the chance a specific object is selected)
		base = float
		modifier = { <add/factor = float> <triggers> }
	}
	<effects>
}
Supported Scopes: country

ordered_owned_starbase - Iterate through every owned primary starbase - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
ordered_owned_starbase = {
	limit = { <triggers> }
	position = <integer, starting with 0>
	order_by = <variable>/trigger:<trigger>
	inverse = yes/no (default: no - if yes, then 0 is lowest rather than highest)
	<effects>
}
Supported Scopes: country

every_owned_starbase - Iterate through every owned primary starbase - executes the enclosed effects on all of them for which the limit triggers return true
every_owned_starbase = { limit = { <triggers> } <effects> }
Supported Scopes: country

random_owned_nonprimary_starbase - Iterate through every owned non-primary starbase (e.g. orbital rings), not including juggernauts - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
random_owned_nonprimary_starbase = {
	limit = { <triggers> }
	weights = { (optional - adds weights to affect the chance a specific object is selected)
		base = float
		modifier = { <add/factor = float> <triggers> }
	}
	<effects>
}
Supported Scopes: country

ordered_owned_nonprimary_starbase - Iterate through every owned non-primary starbase (e.g. orbital rings), not including juggernauts - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
ordered_owned_nonprimary_starbase = {
	limit = { <triggers> }
	position = <integer, starting with 0>
	order_by = <variable>/trigger:<trigger>
	inverse = yes/no (default: no - if yes, then 0 is lowest rather than highest)
	<effects>
}
Supported Scopes: country

every_owned_nonprimary_starbase - Iterate through every owned non-primary starbase (e.g. orbital rings), not including juggernauts - executes the enclosed effects on all of them for which the limit triggers return true
every_owned_nonprimary_starbase = { limit = { <triggers> } <effects> }
Supported Scopes: country

random_system - Iterate through all systems - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
random_system = {
	limit = { <triggers> }
	weights = { (optional - adds weights to affect the chance a specific object is selected)
		base = float
		modifier = { <add/factor = float> <triggers> }
	}
	<effects>
}
Supported Scopes: all

ordered_system - Iterate through all systems - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
ordered_system = {
	limit = { <triggers> }
	position = <integer, starting with 0>
	order_by = <variable>/trigger:<trigger>
	inverse = yes/no (default: no - if yes, then 0 is lowest rather than highest)
	<effects>
}
Supported Scopes: all

every_system - Iterate through all systems - executes the enclosed effects on all of them for which the limit triggers return true
every_system = { limit = { <triggers> } <effects> }
Supported Scopes: all

random_rim_system - Iterate through all rim systems - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
random_rim_system = {
	limit = { <triggers> }
	weights = { (optional - adds weights to affect the chance a specific object is selected)
		base = float
		modifier = { <add/factor = float> <triggers> }
	}
	<effects>
}
Supported Scopes: all

ordered_rim_system - Iterate through all rim systems - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
ordered_rim_system = {
	limit = { <triggers> }
	position = <integer, starting with 0>
	order_by = <variable>/trigger:<trigger>
	inverse = yes/no (default: no - if yes, then 0 is lowest rather than highest)
	<effects>
}
Supported Scopes: all

every_rim_system - Iterate through all rim systems - executes the enclosed effects on all of them for which the limit triggers return true
every_rim_system = { limit = { <triggers> } <effects> }
Supported Scopes: all

random_system_within_border - Iterate through all systems within the country's or sector's borders - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
random_system_within_border = {
	limit = { <triggers> }
	weights = { (optional - adds weights to affect the chance a specific object is selected)
		base = float
		modifier = { <add/factor = float> <triggers> }
	}
	<effects>
}
Supported Scopes: country sector

ordered_system_within_border - Iterate through all systems within the country's or sector's borders - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
ordered_system_within_border = {
	limit = { <triggers> }
	position = <integer, starting with 0>
	order_by = <variable>/trigger:<trigger>
	inverse = yes/no (default: no - if yes, then 0 is lowest rather than highest)
	<effects>
}
Supported Scopes: country sector

every_system_within_border - Iterate through all systems within the country's or sector's borders - executes the enclosed effects on all of them for which the limit triggers return true
every_system_within_border = { limit = { <triggers> } <effects> }
Supported Scopes: country sector

random_neighbor_system - Iterate through all a system's neighboring systems by hyperlane - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
random_neighbor_system = {
	limit = { <triggers> }
	weights = { (optional - adds weights to affect the chance a specific object is selected)
		base = float
		modifier = { <add/factor = float> <triggers> }
	}
	<effects>
}
Supported Scopes: galactic_object

ordered_neighbor_system - Iterate through all a system's neighboring systems by hyperlane - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
ordered_neighbor_system = {
	limit = { <triggers> }
	position = <integer, starting with 0>
	order_by = <variable>/trigger:<trigger>
	inverse = yes/no (default: no - if yes, then 0 is lowest rather than highest)
	<effects>
}
Supported Scopes: galactic_object

every_neighbor_system - Iterate through all a system's neighboring systems by hyperlane - executes the enclosed effects on all of them for which the limit triggers return true
every_neighbor_system = { limit = { <triggers> } <effects> }
Supported Scopes: galactic_object

random_neighbor_system_euclidean - Iterate through all a system's neighboring systems (by closeness, not by hyperlanes) - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
random_neighbor_system_euclidean = {
	limit = { <triggers> }
	weights = { (optional - adds weights to affect the chance a specific object is selected)
		base = float
		modifier = { <add/factor = float> <triggers> }
	}
	<effects>
}
Supported Scopes: galactic_object

ordered_neighbor_system_euclidean - Iterate through all a system's neighboring systems (by closeness, not by hyperlanes) - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
ordered_neighbor_system_euclidean = {
	limit = { <triggers> }
	position = <integer, starting with 0>
	order_by = <variable>/trigger:<trigger>
	inverse = yes/no (default: no - if yes, then 0 is lowest rather than highest)
	<effects>
}
Supported Scopes: galactic_object

every_neighbor_system_euclidean - Iterate through all a system's neighboring systems (by closeness, not by hyperlanes) - executes the enclosed effects on all of them for which the limit triggers return true
every_neighbor_system_euclidean = { limit = { <triggers> } <effects> }
Supported Scopes: galactic_object

random_war_participant - Iterate through all war participants - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
random_war_participant = {
	limit = { <triggers> }
	weights = { (optional - adds weights to affect the chance a specific object is selected)
		base = float
		modifier = { <add/factor = float> <triggers> }
	}
	<effects>
}
Supported Scopes: war

ordered_war_participant - Iterate through all war participants - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
ordered_war_participant = {
	limit = { <triggers> }
	position = <integer, starting with 0>
	order_by = <variable>/trigger:<trigger>
	inverse = yes/no (default: no - if yes, then 0 is lowest rather than highest)
	<effects>
}
Supported Scopes: war

every_war_participant - Iterate through all war participants - executes the enclosed effects on all of them for which the limit triggers return true
every_war_participant = { limit = { <triggers> } <effects> }
Supported Scopes: war

random_attacker - Iterate through all attackers in the current war - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
random_attacker = {
	limit = { <triggers> }
	weights = { (optional - adds weights to affect the chance a specific object is selected)
		base = float
		modifier = { <add/factor = float> <triggers> }
	}
	<effects>
}
Supported Scopes: war

ordered_attacker - Iterate through all attackers in the current war - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
ordered_attacker = {
	limit = { <triggers> }
	position = <integer, starting with 0>
	order_by = <variable>/trigger:<trigger>
	inverse = yes/no (default: no - if yes, then 0 is lowest rather than highest)
	<effects>
}
Supported Scopes: war

every_attacker - Iterate through all attackers in the current war - executes the enclosed effects on all of them for which the limit triggers return true
every_attacker = { limit = { <triggers> } <effects> }
Supported Scopes: war

random_defender - Iterate through all defenders in the current war - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
random_defender = {
	limit = { <triggers> }
	weights = { (optional - adds weights to affect the chance a specific object is selected)
		base = float
		modifier = { <add/factor = float> <triggers> }
	}
	<effects>
}
Supported Scopes: war

ordered_defender - Iterate through all defenders in the current war - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
ordered_defender = {
	limit = { <triggers> }
	position = <integer, starting with 0>
	order_by = <variable>/trigger:<trigger>
	inverse = yes/no (default: no - if yes, then 0 is lowest rather than highest)
	<effects>
}
Supported Scopes: war

every_defender - Iterate through all defenders in the current war - executes the enclosed effects on all of them for which the limit triggers return true
every_defender = { limit = { <triggers> } <effects> }
Supported Scopes: war

random_war - Iterate through all wars the country is engaged in - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object randomly.
random_war = {
	limit = { <triggers> }
	weights = { (optional - adds weights to affect the chance a specific object is selected)
		base = float
		modifier = { <add/factor = float> <triggers> }
	}
	<effects>
}
Supported Scopes: country

ordered_war - Iterate through all wars the country is engaged in - executes the enclosed effects on one of them for which the limit triggers return true. Picks the specific object according to the order specified (position 0, order_by = trigger:num_pops would run the effects on the X with the most pops)
ordered_war = {
	limit = { <triggers> }
	position = <integer, starting with 0>
	order_by = <variable>/trigger:<trigger>
	inverse = yes/no (default: no - if yes, then 0 is lowest rather than highest)
	<effects>
}
Supported Scopes: country

every_war - Iterate through all wars the country is engaged in - executes the enclosed effects on all of them for which the limit triggers return true
every_war = { limit = { <triggers> } <effects> }
Supported Scopes: country


=================
